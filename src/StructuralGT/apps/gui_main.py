# Form implementation generated from reading ui file 'sgt.ui'
#
# Created by: PyQt6 UI code generator 6.4.2
#
# WARNING: Any manual changes made to this file will be lost when pyuic6 is
# run again.  Do not edit this file unless you know what you are doing.


import os
import sys
import time
import logging
from ypstruct import struct
from PIL import Image, ImageQt
from PyQt6 import QtCore, QtGui, QtWidgets
from matplotlib.backends.backend_pdf import PdfPages
from .gui_crop import QCrop
from .. import __title__ as sgt_title
from ..configs.config_loader import load_configs, load_gui_configs, get_num_cores, write_file
from ..SGT.image_processor import ImageProcessor
from ..SGT.graph_converter import GraphConverter
from ..SGT.graph_metrics import GraphMetrics
from ..SGT.graph_metrics_clang import GraphMetricsClang


class MainUI(QtWidgets.QMainWindow):
    def __init__(self):
        super().__init__()
        self.setObjectName("window_main")
        # self.resize(1024, 360)

        self.wdt_main = QtWidgets.QWidget(parent=self)
        self.wdt_main.setObjectName("wdt_main")
        self.setCentralWidget(self.wdt_main)

        self.menu_bar = QtWidgets.QMenuBar(parent=self)
        self.menu_bar.setGeometry(QtCore.QRect(0, 0, 1038, 22))
        self.menu_bar.setObjectName("menu_bar")
        self.setMenuBar(self.menu_bar)

        self.status_bar = QtWidgets.QStatusBar(parent=self)
        self.status_bar.setObjectName("status_bar")
        self.setStatusBar(self.status_bar)

        self.grid_layout_main = QtWidgets.QGridLayout(self.wdt_main)
        self.grid_layout_main.setObjectName("grid_layout_main")

        self.gui_txt = load_gui_configs()

        self.font = QtGui.QFont()
        self.font.setPointSize(8)

        self.bold_font = QtGui.QFont()
        self.bold_font.setPointSize(8)
        self.bold_font.setBold(True)

        self.__create_widgets()

        self.graph_objs = []
        self.current_obj_index = 0
        self.current_img = '0'
        self.img_scale = 1

        self.spb_adaptive_threshold_val = 0
        self.configs_data = {}

        self.error_flag = False
        self.wait_flag = False

        # self.threadpool = QtCore.QThreadPool()
        self.worker = Worker(0, None)
        self._init_configs()

    def __create_widgets(self):
        """
        Create PyQT6 widgets.
        :return:
        """

        # 1. GROUP IMAGE PATH
        self.grp_path = QtWidgets.QGroupBox(parent=self.wdt_main)
        self.grp_path.setTitle("")
        self.grp_path.setObjectName("grp_path")
        self.grp_path.setStyleSheet("QGroupBox#grp_path {border: 1px solid rgb(204,204,0); border-radius: 10px;}")
        self.grid_layout_path = QtWidgets.QGridLayout(self.grp_path)
        self.grid_layout_path.setObjectName("grid_layout_path")
        self._create_img_path()

        # 2. GROUP IMAGE
        self.grp_img = QtWidgets.QGroupBox(parent=self.wdt_main)
        self.grp_img.setObjectName("grp_img")
        self.grp_img.setStyleSheet("QGroupBox#grp_img {border: 1px solid rgb(0,0,255); border-radius: 10px;}")
        self.grid_layout_img = QtWidgets.QGridLayout(self.grp_img)
        self.grid_layout_img.setObjectName("grid_layout_img")
        self._create_img_zoom_controls()
        self._create_img_placeholder()
        self._create_img_navigation_controls()

        # 3. GROUP SETTINGS
        self.grp_settings = QtWidgets.QGroupBox(parent=self.wdt_main)
        self.grp_settings.setEnabled(True)
        size_policy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Policy.Maximum,
                                            QtWidgets.QSizePolicy.Policy.Preferred)
        size_policy.setHorizontalStretch(0)
        size_policy.setVerticalStretch(0)
        size_policy.setHeightForWidth(self.grp_settings.sizePolicy().hasHeightForWidth())
        self.grp_settings.setSizePolicy(size_policy)
        self.grp_settings.setFlat(True)
        self.grp_settings.setObjectName("grp_settings")
        self.grp_settings.setStyleSheet("QGroupBox#grp_settings {border: 0;}")
        self.grid_layout_settings = QtWidgets.QGridLayout(self.grp_settings)
        self.grid_layout_settings.setObjectName("grid_layout_settings")
        self._create_img_filters()
        self._create_bin_filters()
        self._create_metrics_tree()
        self._create_progress_ui()

        # 4. GROUP TASKS
        self.grp_tasks = QtWidgets.QGroupBox(parent=self.wdt_main)
        size_policy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Policy.Maximum,
                                            QtWidgets.QSizePolicy.Policy.Preferred)
        size_policy.setHorizontalStretch(0)
        size_policy.setVerticalStretch(0)
        size_policy.setHeightForWidth(self.grp_tasks.sizePolicy().hasHeightForWidth())
        self.grp_tasks.setSizePolicy(size_policy)
        self.grp_tasks.setTitle("")
        self.grp_tasks.setAlignment(
            QtCore.Qt.AlignmentFlag.AlignBottom | QtCore.Qt.AlignmentFlag.AlignRight |
            QtCore.Qt.AlignmentFlag.AlignTrailing)
        self.grp_tasks.setFlat(True)
        self.grp_tasks.setObjectName("grp_tasks")
        self.grp_tasks.setStyleSheet("QGroupBox#grp_tasks {border: 0;}")
        self.grid_layout_tasks = QtWidgets.QGridLayout(self.grp_tasks)
        self.grid_layout_tasks.setObjectName("grid_layout_tasks")
        self._create_img_properties()
        # Spacer
        spacer_item_2 = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Policy.Minimum,
                                              QtWidgets.QSizePolicy.Policy.Expanding)
        self.grid_layout_tasks.addItem(spacer_item_2, 1, 0, 1, 1)
        self._create_enhancing_tools()
        # Spacer
        spacer_item_2 = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Policy.Minimum,
                                              QtWidgets.QSizePolicy.Policy.Expanding)
        self.grid_layout_tasks.addItem(spacer_item_2, 3, 0, 1, 1)
        self._create_viz_tools()
        # Spacer
        spacer_item_2 = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Policy.Minimum,
                                              QtWidgets.QSizePolicy.Policy.Expanding)
        self.grid_layout_tasks.addItem(spacer_item_2, 5, 0, 1, 1)
        self._create_computation_controls()

        # COLUMN STRETCH
        self.grid_layout_main.setColumnStretch(0, 2)
        self.grid_layout_main.setColumnStretch(1, 5)
        self.grid_layout_main.setColumnStretch(2, 1)

        self.__re_translate_ui()
        QtCore.QMetaObject.connectSlotsByName(self)

    def _create_img_path(self):
        self.btn_grp_img = QtWidgets.QButtonGroup(self)
        self.btn_grp_img.setObjectName("btn_grp_img")
        self.rdo_2d_img = QtWidgets.QRadioButton(parent=self.grp_path)
        self.rdo_2d_img.setObjectName("rdo_2d_img")
        self.rdo_2d_img.setChecked(True)
        self.btn_grp_img.addButton(self.rdo_2d_img)
        self.grid_layout_path.addWidget(self.rdo_2d_img, 0, 4, 1, 1)
        self.rdo_3d_img = QtWidgets.QRadioButton(parent=self.grp_path)
        self.rdo_3d_img.setObjectName("rdo_3d_img")
        self.btn_grp_img.addButton(self.rdo_3d_img)
        self.grid_layout_path.addWidget(self.rdo_3d_img, 0, 5, 1, 1)

        self.lbl_img_path = QtWidgets.QLabel(parent=self.grp_path)
        self.lbl_img_path.setFont(self.bold_font)
        self.lbl_img_path.setObjectName("lbl_img_path")
        self.grid_layout_path.addWidget(self.lbl_img_path, 1, 0, 1, 1)
        self.txt_img_path = QtWidgets.QLineEdit(parent=self.grp_path)
        self.txt_img_path.setObjectName("txt_img_path")
        self.grid_layout_path.addWidget(self.txt_img_path, 1, 1, 1, 1)
        self.btn_select_img_path = QtWidgets.QPushButton(parent=self.grp_path)
        self.btn_select_img_path.setObjectName("btn_select_img_path")
        self.grid_layout_path.addWidget(self.btn_select_img_path, 1, 3, 1, 1)
        self.cbx_multi = QtWidgets.QCheckBox(parent=self.grp_path)
        self.cbx_multi.setObjectName("cbx_multi")
        self.grid_layout_path.addWidget(self.cbx_multi, 1, 4, 1, 2)

        self.lbl_out_path = QtWidgets.QLabel(parent=self.grp_path)
        self.lbl_out_path.setFont(self.bold_font)
        self.lbl_out_path.setObjectName("lbl_out_path")
        self.grid_layout_path.addWidget(self.lbl_out_path, 2, 0, 1, 1)
        self.txt_out_path = QtWidgets.QLineEdit(parent=self.grp_path)
        self.txt_out_path.setObjectName("txt_out_path")
        self.grid_layout_path.addWidget(self.txt_out_path, 2, 1, 1, 1)
        self.btn_select_out_path = QtWidgets.QPushButton(parent=self.grp_path)
        self.btn_select_out_path.setObjectName("btn_select_out_path")
        self.grid_layout_path.addWidget(self.btn_select_out_path, 2, 3, 1, 1)
        self.grid_layout_main.addWidget(self.grp_path, 0, 1, 1, 2)

    def _create_img_zoom_controls(self):
        """Create components and controls for zooming in/out of image."""
        self.grp_img_zoom = QtWidgets.QGroupBox(parent=self.grp_img)
        size_policy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Policy.Preferred, QtWidgets.QSizePolicy.Policy.Fixed)
        size_policy.setHorizontalStretch(0)
        size_policy.setVerticalStretch(0)
        size_policy.setHeightForWidth(self.grp_img_zoom.sizePolicy().hasHeightForWidth())
        self.grp_img_zoom.setSizePolicy(size_policy)
        self.grp_img_zoom.setTitle("")
        self.grp_img_zoom.setFlat(True)
        self.grp_img_zoom.setObjectName("grp_img_zoom")
        self.grp_img_zoom.setStyleSheet("QGroupBox#grp_img_zoom {border: 0;}")
        self.grid_layout_zoom = QtWidgets.QGridLayout(self.grp_img_zoom)
        self.grid_layout_zoom.setObjectName("grid_layout_zoom")

        self.btn_zoom_out = QtWidgets.QPushButton(parent=self.grp_img_zoom)
        self.btn_zoom_out.setObjectName("btn_zoom_out")
        self.grid_layout_zoom.addWidget(self.btn_zoom_out, 0, 0, 1, 1)

        # Spacer
        spacer_item_1 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Policy.Expanding,
                                              QtWidgets.QSizePolicy.Policy.Minimum)
        self.grid_layout_zoom.addItem(spacer_item_1, 0, 1, 1, 1)

        self.lbl_zoom = QtWidgets.QLabel(parent=self.grp_img_zoom)
        self.lbl_zoom.setObjectName("lbl_zoom")
        self.grid_layout_zoom.addWidget(self.lbl_zoom, 0, 2, 1, 1)

        # Spacer
        spacer_item_2 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Policy.Expanding,
                                              QtWidgets.QSizePolicy.Policy.Minimum)
        self.grid_layout_zoom.addItem(spacer_item_2, 0, 3, 1, 1)

        self.btn_zoom_in = QtWidgets.QPushButton(parent=self.grp_img_zoom)
        self.btn_zoom_in.setObjectName("btn_zoom_in")
        self.grid_layout_zoom.addWidget(self.btn_zoom_in, 0, 4, 1, 1)
        self.grid_layout_img.addWidget(self.grp_img_zoom, 0, 0, 1, 1)

    def _create_img_placeholder(self):
        """Create placeholder for image."""
        self.sca_img = QtWidgets.QScrollArea(parent=self.grp_img)
        self.sca_img.setWidgetResizable(True)
        self.sca_img.setObjectName("sca_img")
        self.scroll_area_img = QtWidgets.QWidget()
        self.scroll_area_img.setObjectName("scroll_area_img")
        self.grid_layout_img_scroll = QtWidgets.QGridLayout(self.scroll_area_img)
        self.grid_layout_img_scroll.setObjectName("grid_layout_img_scroll")
        self.lbl_img = QtWidgets.QLabel(parent=self.scroll_area_img)
        self.lbl_img.setAlignment(QtCore.Qt.AlignmentFlag.AlignCenter)
        self.lbl_img.setObjectName("lbl_img")
        self.grid_layout_img_scroll.addWidget(self.lbl_img, 0, 0, 1, 1)
        self.sca_img.setWidget(self.scroll_area_img)
        self.grid_layout_img.addWidget(self.sca_img, 1, 0, 1, 1)

    def _create_img_navigation_controls(self):
        """Create navigation controls for image."""
        self.grp_img_nav = QtWidgets.QGroupBox(parent=self.grp_img)
        size_policy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Policy.Preferred, QtWidgets.QSizePolicy.Policy.Fixed)
        size_policy.setHorizontalStretch(0)
        size_policy.setVerticalStretch(0)
        size_policy.setHeightForWidth(self.grp_img_nav.sizePolicy().hasHeightForWidth())
        self.grp_img_nav.setSizePolicy(size_policy)
        self.grp_img_nav.setTitle("")
        self.grp_img_nav.setFlat(True)
        self.grp_img_nav.setObjectName("grp_img_nav")
        self.grp_img_nav.setStyleSheet("QGroupBox#grp_img_nav {border: 0;}")
        self.grid_layout_img_nav = QtWidgets.QGridLayout(self.grp_img_nav)
        self.grid_layout_img_nav.setObjectName("grid_layout_img_nav")
        self.btn_prev = QtWidgets.QPushButton(parent=self.grp_img_nav)
        self.btn_prev.setEnabled(False)
        self.btn_prev.setObjectName("btn_prev")
        self.grid_layout_img_nav.addWidget(self.btn_prev, 0, 0, 1, 1)
        self.btn_next = QtWidgets.QPushButton(parent=self.grp_img_nav)
        self.btn_next.setEnabled(False)
        self.btn_next.setObjectName("btn_next")
        self.grid_layout_img_nav.addWidget(self.btn_next, 0, 2, 1, 1)
        spacer_item = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Policy.Expanding,
                                            QtWidgets.QSizePolicy.Policy.Minimum)
        self.grid_layout_img_nav.addItem(spacer_item, 0, 1, 1, 1)
        self.grid_layout_img.addWidget(self.grp_img_nav, 2, 0, 1, 1)
        self.grid_layout_main.addWidget(self.grp_img, 1, 1, 1, 1)

    def _create_img_filters(self):
        """Create image filters group components and controls."""
        self.grp_img_filters = QtWidgets.QGroupBox(parent=self.grp_settings)
        self.grp_img_filters.setObjectName("grp_img_filters")
        self.grp_img_filters.setStyleSheet("QGroupBox#grp_img_filters {border: 1px solid rgb(224,224,224);}")
        self.grp_img_filters.setFont(self.bold_font)
        self.grid_layout_filters = QtWidgets.QGridLayout(self.grp_img_filters)
        self.grid_layout_filters.setObjectName("grid_layout_filters")
        self.cbx_laplacian = QtWidgets.QCheckBox(parent=self.grp_img_filters)
        self.cbx_laplacian.setObjectName("cbx_laplacian")
        self.grid_layout_filters.addWidget(self.cbx_laplacian, 4, 0, 1, 1)
        self.sld_gaussian = QtWidgets.QSlider(parent=self.grp_img_filters)
        self.sld_gaussian.setMinimum(1)
        self.sld_gaussian.setSingleStep(1)
        self.sld_gaussian.setPageStep(10)
        self.sld_gaussian.setOrientation(QtCore.Qt.Orientation.Horizontal)
        self.sld_gaussian.setTickPosition(QtWidgets.QSlider.TickPosition.TicksAbove)
        self.sld_gaussian.setObjectName("sld_gaussian")
        self.grid_layout_filters.addWidget(self.sld_gaussian, 1, 1, 1, 1)
        self.sld_lut_gamma = QtWidgets.QSlider(parent=self.grp_img_filters)
        self.sld_lut_gamma.setMinimum(1)
        self.sld_lut_gamma.setMaximum(500)
        self.sld_lut_gamma.setSingleStep(1)
        self.sld_lut_gamma.setPageStep(100)
        self.sld_lut_gamma.setOrientation(QtCore.Qt.Orientation.Horizontal)
        self.sld_lut_gamma.setTickPosition(QtWidgets.QSlider.TickPosition.TicksAbove)
        self.sld_lut_gamma.setObjectName("sld_lut_gamma")
        self.grid_layout_filters.addWidget(self.sld_lut_gamma, 0, 1, 1, 1)
        self.lbl_lut_gamma = CustomQLabel(parent=self.grp_img_filters)
        self.lbl_lut_gamma.setFixedWidth(30)
        self.lbl_lut_gamma.setAlignment(QtCore.Qt.AlignmentFlag.AlignCenter)
        self.lbl_lut_gamma.setObjectName("lbl_lut_gamma")
        self.grid_layout_filters.addWidget(self.lbl_lut_gamma, 0, 2, 1, 1)
        self.cbx_autolevel = QtWidgets.QCheckBox(parent=self.grp_img_filters)
        self.cbx_autolevel.setObjectName("cbx_autolevel")
        self.grid_layout_filters.addWidget(self.cbx_autolevel, 2, 0, 1, 1)
        self.cbx_gaussian_blur = QtWidgets.QCheckBox(parent=self.grp_img_filters)
        self.cbx_gaussian_blur.setObjectName("cbx_gaussian_blur")
        self.grid_layout_filters.addWidget(self.cbx_gaussian_blur, 1, 0, 1, 1)
        self.lbl_lut_gamma_title = QtWidgets.QLabel(parent=self.grp_img_filters)
        self.lbl_lut_gamma_title.setObjectName("lbl_lut_gamma_title")
        self.grid_layout_filters.addWidget(self.lbl_lut_gamma_title, 0, 0, 1, 1)
        self.cbx_scharr = QtWidgets.QCheckBox(parent=self.grp_img_filters)
        self.cbx_scharr.setObjectName("cbx_scharr")
        self.grid_layout_filters.addWidget(self.cbx_scharr, 7, 0, 1, 1)
        self.cbx_median = QtWidgets.QCheckBox(parent=self.grp_img_filters)
        self.cbx_median.setObjectName("cbx_median")
        self.grid_layout_filters.addWidget(self.cbx_median, 8, 0, 1, 1)
        self.sld_autolevel = QtWidgets.QSlider(parent=self.grp_img_filters)
        self.sld_autolevel.setMinimum(1)
        self.sld_autolevel.setSingleStep(2)
        self.sld_autolevel.setOrientation(QtCore.Qt.Orientation.Horizontal)
        self.sld_autolevel.setTickPosition(QtWidgets.QSlider.TickPosition.TicksAbove)
        self.sld_autolevel.setObjectName("sld_autolevel")
        self.grid_layout_filters.addWidget(self.sld_autolevel, 2, 1, 1, 1)
        self.lbl_autolevel = CustomQLabel(parent=self.grp_img_filters)
        self.lbl_autolevel.setFixedWidth(30)
        self.lbl_autolevel.setAlignment(QtCore.Qt.AlignmentFlag.AlignCenter)
        self.lbl_autolevel.setObjectName("lbl_autolevel")
        self.grid_layout_filters.addWidget(self.lbl_autolevel, 2, 2, 1, 1)
        self.lbl_sobel = CustomQLabel(parent=self.grp_img_filters)
        self.lbl_sobel.setFixedWidth(30)
        self.lbl_sobel.setAlignment(QtCore.Qt.AlignmentFlag.AlignCenter)
        self.lbl_sobel.setObjectName("lbl_sobel")
        self.grid_layout_filters.addWidget(self.lbl_sobel, 5, 2, 1, 1)
        self.sld_laplacian = QtWidgets.QSlider(parent=self.grp_img_filters)
        self.sld_laplacian.setMinimum(1)
        self.sld_laplacian.setMaximum(7)
        self.sld_laplacian.setSingleStep(2)
        self.sld_laplacian.setPageStep(2)
        self.sld_laplacian.setOrientation(QtCore.Qt.Orientation.Horizontal)
        self.sld_laplacian.setTickPosition(QtWidgets.QSlider.TickPosition.TicksAbove)
        self.sld_laplacian.setObjectName("sld_laplacian")
        self.grid_layout_filters.addWidget(self.sld_laplacian, 4, 1, 1, 1)
        self.sld_sobel = QtWidgets.QSlider(parent=self.grp_img_filters)
        self.sld_sobel.setMinimum(1)
        self.sld_sobel.setMaximum(7)
        self.sld_sobel.setSingleStep(2)
        self.sld_sobel.setPageStep(2)
        self.sld_sobel.setOrientation(QtCore.Qt.Orientation.Horizontal)
        self.sld_sobel.setTickPosition(QtWidgets.QSlider.TickPosition.TicksAbove)
        self.sld_sobel.setObjectName("sld_sobel")
        self.grid_layout_filters.addWidget(self.sld_sobel, 5, 1, 1, 1)
        self.cbx_sobel = QtWidgets.QCheckBox(parent=self.grp_img_filters)
        self.cbx_sobel.setObjectName("cbx_sobel")
        self.grid_layout_filters.addWidget(self.cbx_sobel, 5, 0, 1, 1)
        self.lbl_gaussian = CustomQLabel(parent=self.grp_img_filters)
        self.lbl_gaussian.setFixedWidth(30)
        self.lbl_gaussian.setAlignment(QtCore.Qt.AlignmentFlag.AlignCenter)
        self.lbl_gaussian.setObjectName("lbl_gaussian")
        self.grid_layout_filters.addWidget(self.lbl_gaussian, 1, 2, 1, 1)
        self.lbl_laplacian = CustomQLabel(parent=self.grp_img_filters)
        self.lbl_laplacian.setFixedWidth(30)
        self.lbl_laplacian.setAlignment(QtCore.Qt.AlignmentFlag.AlignCenter)
        self.lbl_laplacian.setObjectName("lbl_laplacian")
        self.grid_layout_filters.addWidget(self.lbl_laplacian, 4, 2, 1, 1)
        self.cbx_lowpass = QtWidgets.QCheckBox(parent=self.grp_img_filters)
        self.cbx_lowpass.setObjectName("cbx_lowpass")
        self.grid_layout_filters.addWidget(self.cbx_lowpass, 6, 0, 1, 1)
        self.spb_lowpass = QtWidgets.QSpinBox(parent=self.grp_img_filters)
        self.spb_lowpass.setAlignment(QtCore.Qt.AlignmentFlag.AlignCenter)
        self.spb_lowpass.setObjectName("spb_lowpass")
        self.grid_layout_filters.addWidget(self.spb_lowpass, 6, 1, 1, 2)
        self.grid_layout_filters.setColumnStretch(0, 1)
        self.grid_layout_filters.setColumnStretch(1, 6)
        self.grid_layout_filters.setColumnStretch(2, 1)
        self.grid_layout_settings.addWidget(self.grp_img_filters, 0, 0, 1, 1)

    def _create_bin_filters(self):
        """Create image binary group components and controls."""
        self.grp_img_binary = QtWidgets.QGroupBox(parent=self.grp_settings)
        self.grp_img_binary.setObjectName("grp_img_binary")
        self.grp_img_binary.setStyleSheet("QGroupBox#grp_img_binary {border: 1px solid rgb(224,224,224);}")
        self.grp_img_binary.setFont(self.bold_font)
        self.grid_layout_binary = QtWidgets.QGridLayout(self.grp_img_binary)
        self.grid_layout_binary.setObjectName("grid_layout_binary")
        self.rdo_otsu_threshold = QtWidgets.QRadioButton(parent=self.grp_img_binary)
        self.rdo_otsu_threshold.setObjectName("rdo_otsu_threshold")
        self.btn_grp_binary = QtWidgets.QButtonGroup(self)
        self.btn_grp_binary.setObjectName("btn_grp_binary")
        self.btn_grp_binary.addButton(self.rdo_otsu_threshold)
        self.grid_layout_binary.addWidget(self.rdo_otsu_threshold, 3, 0, 1, 1)
        self.sld_global_threshold = QtWidgets.QSlider(parent=self.grp_img_binary)
        self.sld_global_threshold.setMinimum(1)
        self.sld_global_threshold.setMaximum(255)
        self.sld_global_threshold.setProperty("value", 127)
        self.sld_global_threshold.setTracking(True)
        self.sld_global_threshold.setOrientation(QtCore.Qt.Orientation.Horizontal)
        self.sld_global_threshold.setInvertedAppearance(False)
        self.sld_global_threshold.setInvertedControls(False)
        self.sld_global_threshold.setTickPosition(QtWidgets.QSlider.TickPosition.TicksAbove)
        self.sld_global_threshold.setObjectName("sld_global_threshold")
        self.grid_layout_binary.addWidget(self.sld_global_threshold, 1, 1, 1, 1)
        self.rdo_adaptive_threshold = QtWidgets.QRadioButton(parent=self.grp_img_binary)
        self.rdo_adaptive_threshold.setObjectName("rdo_adaptive_threshold")
        self.btn_grp_binary.addButton(self.rdo_adaptive_threshold)
        self.grid_layout_binary.addWidget(self.rdo_adaptive_threshold, 2, 0, 1, 1)
        self.rdo_global_threshold = QtWidgets.QRadioButton(parent=self.grp_img_binary)
        self.rdo_global_threshold.setChecked(True)
        self.rdo_global_threshold.setObjectName("rdo_global_threshold")
        self.btn_grp_binary.addButton(self.rdo_global_threshold)
        self.grid_layout_binary.addWidget(self.rdo_global_threshold, 1, 0, 1, 1)
        self.lbl_global_threshold_value = CustomQLabel(parent=self.grp_img_binary)
        self.lbl_global_threshold_value.setFixedWidth(30)
        self.lbl_global_threshold_value.setAlignment(QtCore.Qt.AlignmentFlag.AlignCenter)
        self.lbl_global_threshold_value.setObjectName("lbl_global_threshold_value")
        self.grid_layout_binary.addWidget(self.lbl_global_threshold_value, 1, 2, 1, 1)
        self.cbx_dark_foreground = QtWidgets.QCheckBox(parent=self.grp_img_binary)
        self.cbx_dark_foreground.setObjectName("cbx_dark_foreground")
        self.grid_layout_binary.addWidget(self.cbx_dark_foreground, 4, 0, 1, 3)
        self.spb_adaptive_threshold = QtWidgets.QSpinBox(parent=self.grp_img_binary)
        self.spb_adaptive_threshold.setAlignment(QtCore.Qt.AlignmentFlag.AlignCenter)
        self.spb_adaptive_threshold.setMaximum(10000)
        self.spb_adaptive_threshold.setObjectName("spb_adaptive_threshold")
        self.grid_layout_binary.addWidget(self.spb_adaptive_threshold, 2, 1, 1, 2)
        self.grid_layout_binary.setColumnStretch(0, 1)
        self.grid_layout_binary.setColumnStretch(1, 6)
        self.grid_layout_binary.setColumnStretch(2, 1)
        self.grid_layout_settings.addWidget(self.grp_img_binary, 1, 0, 1, 1)

    def _create_metrics_tree(self):
        """Add Tree for selecting GT metrics to be computed."""
        self.tree_settings = QtWidgets.QTreeView(parent=self.grp_settings)
        self.tree_settings.setObjectName("tree_settings")
        self.tree_settings.setStyleSheet("QTreeView#tree_settings {border: 1px solid rgb(224,224,224);}")
        self.grid_layout_settings.addWidget(self.tree_settings, 2, 0, 1, 1)

    def _create_progress_ui(self):
        """Create Progress group components and controls."""
        self.grp_progress = QtWidgets.QGroupBox(parent=self.grp_settings)
        self.grp_progress.setTitle("")
        self.grp_progress.setFlat(True)
        self.grp_progress.setObjectName("grp_progress")
        self.grp_progress.setStyleSheet("QGroupBox#grp_progress {border: 0;}")
        self.grid_layout_progress = QtWidgets.QGridLayout(self.grp_progress)
        self.grid_layout_progress.setObjectName("grid_layout_progress")
        self.lbl_progress = QtWidgets.QLabel(parent=self.grp_progress)
        self.lbl_progress.setStyleSheet("color: rgb(0,128,0)")
        self.lbl_progress.setObjectName("lbl_progress")
        self.grid_layout_progress.addWidget(self.lbl_progress, 0, 0, 1, 2)
        self.progress_bar_main = QtWidgets.QProgressBar(parent=self.grp_progress)
        self.progress_bar_main.setProperty("value", 0)
        self.progress_bar_main.setTextVisible(False)
        self.progress_bar_main.setObjectName("progress_bar_main")
        self.grid_layout_progress.addWidget(self.progress_bar_main, 1, 0, 1, 2)
        self.lbl_info = QtWidgets.QLabel(parent=self.grp_progress)
        self.lbl_info.setFont(self.font)
        self.lbl_info.setObjectName("lbl_info")
        self.grid_layout_progress.addWidget(self.lbl_info, 2, 0, 1, 1)
        self.btn_cancel = QtWidgets.QPushButton(parent=self.grp_progress)
        self.btn_cancel.setFont(self.font)
        self.btn_cancel.setObjectName("btn_cancel")
        self.grid_layout_progress.addWidget(self.btn_cancel, 2, 1, 1, 1)
        self.grid_layout_settings.addWidget(self.grp_progress, 3, 0, 1, 1)
        self.grid_layout_main.addWidget(self.grp_settings, 0, 0, 2, 1)

    def _create_img_properties(self):
        """Create components and controls to capture pixel properties of image."""
        self.grp_properties = QtWidgets.QGroupBox(parent=self.grp_tasks)
        self.grp_properties.setObjectName("grp_properties")
        self.grp_properties.setStyleSheet("QGroupBox#grp_properties {border: 1px solid rgb(224,224,224);}")
        self.grp_properties.setFont(self.bold_font)
        self.grid_layout_properties = QtWidgets.QGridLayout(self.grp_properties)
        self.grid_layout_properties.setObjectName("grid_layout_properties")

        self.lbl_scalebar_value = QtWidgets.QLabel(parent=self.grp_properties)
        self.lbl_scalebar_value.setFont(self.font)
        self.lbl_scalebar_value.setObjectName("lbl_scalebar_value")
        self.grid_layout_properties.addWidget(self.lbl_scalebar_value, 0, 0, 1, 1)
        self.txt_scalebar_val = QtWidgets.QLineEdit(parent=self.grp_properties)
        self.txt_scalebar_val.setFont(self.font)
        self.txt_scalebar_val.setObjectName("txt_scalebar_val")
        self.grid_layout_properties.addWidget(self.txt_scalebar_val, 0, 1, 1, 1)

        self.lbl_scalebar_pixels = QtWidgets.QLabel(parent=self.grp_properties)
        self.lbl_scalebar_pixels.setFont(self.font)
        self.lbl_scalebar_pixels.setObjectName("lbl_scalebar_pixels")
        self.grid_layout_properties.addWidget(self.lbl_scalebar_pixels, 1, 0, 1, 1)
        self.txt_scalebar_px = QtWidgets.QLineEdit(parent=self.grp_properties)
        self.txt_scalebar_px.setFont(self.font)
        self.txt_scalebar_px.setObjectName("txt_scalebar_px")
        self.grid_layout_properties.addWidget(self.txt_scalebar_px, 1, 1, 1, 1)
        self.lbl_resistivity = QtWidgets.QLabel(parent=self.grp_properties)
        self.lbl_resistivity.setFont(self.font)
        self.lbl_resistivity.setObjectName("lbl_resistivity")
        self.grid_layout_properties.addWidget(self.lbl_resistivity, 2, 0, 1, 1)
        self.txt_resistivity = QtWidgets.QLineEdit(parent=self.grp_properties)
        self.txt_resistivity.setFont(self.font)
        self.txt_resistivity.setObjectName("txt_resistivity")
        self.grid_layout_properties.addWidget(self.txt_resistivity, 2, 1, 1, 1)
        self.grid_layout_tasks.addWidget(self.grp_properties, 0, 0, 1, 2)

    def _create_enhancing_tools(self):
        """Create components and controls for enhancing brightness and contrast of image."""
        self.grp_crop = QtWidgets.QGroupBox(parent=self.grp_tasks)
        self.grp_crop.setObjectName("grp_crop")
        self.grp_crop.setStyleSheet("QGroupBox#grp_crop {border: 1px solid rgb(224,224,224);}")
        self.grp_crop.setFont(self.bold_font)
        self.grid_layout_crop = QtWidgets.QGridLayout(self.grp_crop)
        self.grid_layout_crop.setObjectName("grid_layout_crop")
        # self.btn_reset_filters = QtWidgets.QPushButton(parent=self.grp_crop)
        # self.btn_reset_filters.setObjectName("btn_reset_filters")
        # self.grid_layout_crop.addWidget(self.btn_reset_filters, 0, 0, 1, 2)
        self.btn_crop = QtWidgets.QPushButton(parent=self.grp_crop)
        self.btn_crop.setFont(self.font)
        self.btn_crop.setObjectName("btn_crop")
        self.grid_layout_crop.addWidget(self.btn_crop, 0, 0, 1, 2)
        self.spb_brightness = QtWidgets.QSpinBox(parent=self.grp_crop)
        self.spb_brightness.setFont(self.font)
        self.spb_brightness.setAlignment(QtCore.Qt.AlignmentFlag.AlignCenter)
        self.spb_brightness.setMinimum(-100)
        self.spb_brightness.setMaximum(100)
        self.spb_brightness.setProperty("value", 0)
        self.spb_brightness.setObjectName("spb_brightness")
        self.grid_layout_crop.addWidget(self.spb_brightness, 1, 1, 1, 1)
        self.spb_contrast = QtWidgets.QSpinBox(parent=self.grp_crop)
        self.spb_contrast.setFont(self.font)
        self.spb_contrast.setAlignment(QtCore.Qt.AlignmentFlag.AlignCenter)
        self.spb_contrast.setMinimum(-100)
        self.spb_contrast.setMaximum(100)
        self.spb_contrast.setObjectName("spb_contrast")
        self.grid_layout_crop.addWidget(self.spb_contrast, 2, 1, 1, 1)
        self.lbl_brightness = QtWidgets.QLabel(parent=self.grp_crop)
        self.lbl_brightness.setFont(self.font)
        self.lbl_brightness.setObjectName("lbl_brightness")
        self.grid_layout_crop.addWidget(self.lbl_brightness, 1, 0, 1, 1)
        self.lbl_contrast = QtWidgets.QLabel(parent=self.grp_crop)
        self.lbl_contrast.setFont(self.font)
        self.lbl_contrast.setObjectName("lbl_contrast")
        self.grid_layout_crop.addWidget(self.lbl_contrast, 2, 0, 1, 1)
        self.grid_layout_tasks.addWidget(self.grp_crop, 2, 0, 1, 2)

    def _create_viz_tools(self):
        """Create components and controls for visualizing extracted graph."""
        self.grp_graph = QtWidgets.QGroupBox(parent=self.grp_tasks)
        self.grp_graph.setObjectName("grp_graph")
        self.grp_graph.setStyleSheet("QGroupBox#grp_graph {border: 1px solid rgb(224,224,224);}")
        self.grp_graph.setFont(self.bold_font)
        self.grid_layout_graph = QtWidgets.QGridLayout(self.grp_graph)
        self.grid_layout_graph.setObjectName("grid_layout_graph")
        self.cb_show_img = QtWidgets.QComboBox(parent=self.grp_graph)
        self.cb_show_img.setFont(self.font)
        self.cb_show_img.setObjectName("cb_show_img")
        self.cb_show_img.addItems(['Original Image', 'Processed Image', 'Binary Image'])
        self.cb_show_img.setCurrentIndex(0)
        self.grid_layout_graph.addWidget(self.cb_show_img, 0, 0, 1, 1)
        self.btn_show_graph = QtWidgets.QPushButton(parent=self.grp_graph)
        self.btn_show_graph.setFont(self.font)
        self.btn_show_graph.setObjectName("btn_show_graph")
        self.grid_layout_graph.addWidget(self.btn_show_graph, 1, 0, 1, 1)
        self.btn_quick_graph_metrics = QtWidgets.QPushButton(parent=self.grp_graph)
        self.btn_quick_graph_metrics.setFont(self.font)
        self.btn_quick_graph_metrics.setObjectName("btn_quick_graph_metrics")
        self.grid_layout_graph.addWidget(self.btn_quick_graph_metrics, 2, 0, 1, 1)
        self.btn_save_files = QtWidgets.QPushButton(parent=self.grp_graph)
        self.btn_save_files.setFont(self.font)
        self.btn_save_files.setObjectName("btn_save_files")
        self.grid_layout_graph.addWidget(self.btn_save_files, 3, 0, 1, 1)
        self.grid_layout_tasks.addWidget(self.grp_graph, 4, 0, 1, 2)

    def _create_computation_controls(self):
        """Create buttons and controls for initiating GT computation."""
        self.grp_compute = QtWidgets.QGroupBox(parent=self.grp_tasks)
        self.grp_compute.setObjectName("grp_compute")
        self.grp_compute.setStyleSheet("QGroupBox#grp_compute {border: 1px solid rgb(224,224,224);}")
        self.grp_compute.setFont(self.bold_font)
        self.grid_layout_compute = QtWidgets.QGridLayout(self.grp_compute)
        self.grid_layout_compute.setObjectName("grid_layout_compute")
        self.cbx_igraph = QtWidgets.QCheckBox(parent=self.grp_compute)
        self.cbx_igraph.setFont(self.font)
        self.cbx_igraph.setObjectName("cbx_igraph")
        self.grid_layout_compute.addWidget(self.cbx_igraph, 1, 0, 1, 1)
        self.btn_gt_metrics = QtWidgets.QPushButton(parent=self.grp_compute)
        self.btn_gt_metrics.setObjectName("btn_gt_metrics")
        self.grid_layout_compute.addWidget(self.btn_gt_metrics, 2, 0, 1, 1)
        self.btn_gt_metrics_all = QtWidgets.QPushButton(parent=self.grp_compute)
        self.btn_gt_metrics_all.setObjectName("btn_gt_metrics_all")
        self.grid_layout_compute.addWidget(self.btn_gt_metrics_all, 3, 0, 1, 1)
        # self.btn_chaos_gt = QtWidgets.QPushButton(parent=self.grp_compute)
        # self.btn_chaos_gt.setObjectName("btn_chaos_gt")
        # self.grid_layout_compute.addWidget(self.btn_chaos_gt, 4, 0, 1, 1)
        self.grid_layout_tasks.addWidget(self.grp_compute, 6, 0, 1, 2)

        # About Button
        self.btn_about = QtWidgets.QPushButton(parent=self.grp_tasks)
        self.btn_about.setObjectName("btn_about")
        self.btn_about.setFont(self.font)
        self.grid_layout_tasks.addWidget(self.btn_about, 7, 0, 1, 2)
        self.grid_layout_main.addWidget(self.grp_tasks, 1, 2, 1, 1)

    def __re_translate_ui(self):
        _translate = QtCore.QCoreApplication.translate
        self.setWindowTitle(_translate("window_main", sgt_title))
        self.btn_prev.setText(_translate("window_main", "<< previous"))
        self.btn_next.setText(_translate("window_main", "next >>"))
        self.lbl_zoom.setText(_translate("window_main", "Zoom"))
        self.btn_zoom_out.setText(_translate("window_main", "-"))
        self.btn_zoom_in.setText(_translate("window_main", "+"))
        self.lbl_img.setText(_translate("window_main", ""))
        self.grp_compute.setTitle(_translate("window_main", "Computations"))
        self.cbx_igraph.setText(_translate("window_main", "use iGraph with C"))
        self.btn_gt_metrics.setText(_translate("window_main", "GT Metrics"))
        self.btn_gt_metrics_all.setText(_translate("window_main", " GT Metrics (multi) "))
        # self.btn_chaos_gt.setText(_translate("window_main", "Chaos GT"))
        self.btn_about.setText(_translate("window_main", "About StructuralGT"))
        self.grp_graph.setTitle(_translate("window_main", "Visualizations"))
        # self.btn_reset_filters.setText(_translate("window_main", "Reset to Default"))
        self.btn_show_graph.setText(_translate("window_main", "Show Graph"))
        self.btn_quick_graph_metrics.setText(_translate("window_main", "Quick Metrics"))
        self.btn_save_files.setText(_translate("window_main", "Save Files"))
        self.grp_properties.setTitle(_translate("window_main", "Microscopy Properties"))
        self.lbl_scalebar_value.setText(_translate("window_main", "Scalebar (nm)"))
        self.lbl_scalebar_pixels.setText(_translate("window_main", "Pixel Count\n(scalebar)"))
        self.lbl_resistivity.setText(_translate("window_main", "Resistivity (<html>&Omega;</html>m)"))

        self.grp_crop.setTitle(_translate("window_main", "Enhancing Tools"))
        self.btn_crop.setText(_translate("window_main", "Crop"))
        self.lbl_brightness.setText(_translate("window_main", "Brightness"))
        self.lbl_contrast.setText(_translate("window_main", "Contrast"))
        self.rdo_2d_img.setText(_translate("window_main", "2D"))
        self.rdo_3d_img.setText(_translate("window_main", "3D"))
        self.lbl_out_path.setText(_translate("window_main", "Output Dir"))
        self.btn_select_out_path.setText(_translate("window_main", "Select"))
        self.btn_select_img_path.setText(_translate("window_main", "Select"))
        self.lbl_img_path.setText(_translate("window_main", "Image Path"))
        self.cbx_multi.setText(_translate("window_main", "Multiple Images"))
        # self.grp_settings.setTitle(_translate("window_main", "Settings"))
        self.grp_img_filters.setTitle(_translate("window_main", "Image Filters"))
        self.cbx_laplacian.setText(_translate("window_main", "Laplacian"))
        self.lbl_lut_gamma.setText(_translate("window_main", "5"))
        self.cbx_autolevel.setText(_translate("window_main", "Auto Level"))
        self.cbx_gaussian_blur.setText(_translate("window_main", "Gaussian Blur"))
        self.lbl_lut_gamma_title.setText(_translate("window_main", "LUT Gamma"))
        self.cbx_scharr.setText(_translate("window_main", "Scharr"))
        self.cbx_median.setText(_translate("window_main", "Median"))
        self.lbl_autolevel.setText(_translate("window_main", "10"))
        self.lbl_sobel.setText(_translate("window_main", "3"))
        self.cbx_sobel.setText(_translate("window_main", "Sobel"))
        self.lbl_gaussian.setText(_translate("window_main", "10"))
        self.lbl_laplacian.setText(_translate("window_main", "3"))
        self.cbx_lowpass.setText(_translate("window_main", "Lowpass"))
        self.lbl_progress.setText(_translate("window_main", ""))
        self.lbl_info.setText(_translate("window_main", "welcome..."))
        self.btn_cancel.setText(_translate("window_main", "Cancel"))
        self.grp_img_binary.setTitle(_translate("window_main", "Binary Filters"))
        self.rdo_otsu_threshold.setText(_translate("window_main", "OTSU"))
        self.rdo_adaptive_threshold.setText(_translate("window_main", "Adaptive"))
        self.rdo_global_threshold.setText(_translate("window_main", "Global"))
        self.lbl_global_threshold_value.setText(_translate("window_main", "120"))
        self.cbx_dark_foreground.setText(_translate("window_main", "Apply Dark Foreground"))

    def _init_configs(self):
        """
        Initialize all UI configurations.

        :return:
        """
        # 1. Fetch configs
        self.configs_data = load_configs()
        options = self.configs_data['main_options']
        options_img = self.configs_data['filter_options']
        options_gte = self.configs_data['extraction_options']
        options_gtc = self.configs_data['sgt_options']

        # 2. Initialize Settings
        self._init_tree(options_gte, options_gtc)

        # 3. Initialize Filter Settings
        self._init_img_filter_settings(options_img)

        # 4. Initialize Binary Settings
        self._init_img_binary_settings(options_img)

        # 5. Initialize Enhance and Compute Tools
        self._init_tools()

        # 6. initialize Image Paths
        self._init_img_path_settings(options)

    def _init_tree(self, options_gte, options_gtc):
        """
        Initialize drop-down tree items.
        :param options_gte:
        :param options_gtc:
        :return:
        """

        if options_gtc.compute_lang == 'C':
            self.cbx_igraph.setChecked(True)
        else:
            self.cbx_igraph.setChecked(False)

        # 1. Init treeview
        self.tree_settings.setHeaderHidden(True)
        tree_model = QtGui.QStandardItemModel()
        root_node = tree_model.invisibleRootItem()

        # 2. Add Extraction items
        options_extraction = TreeTextItem('Extraction Options', 9, set_bold=True, color=QtGui.QColor(0, 0, 200))
        # tree_model.setItem(0, 0, options_extraction)  # row, col, item

        # --- start ---
        weighted_item = TreeItem(self.gui_txt.weighted, 8, set_checkable=True,
                                 color=QtGui.QColor(0, 0, 200), data=options_gte.has_weights)

        by_diameter_item = TreeItem(self.gui_txt.weight_by_dia, 6, set_checkable=True,
                                    color=QtGui.QColor(0, 0, 200), data=1)
        by_diameter_item.setData('RdoItem_Wt', QtCore.Qt.ItemDataRole.UserRole)
        by_area_item = TreeItem(self.gui_txt.weight_by_area, 6, set_checkable=True,
                                color=QtGui.QColor(0, 0, 200), data=0)
        by_area_item.setData('RdoItem_Wt', QtCore.Qt.ItemDataRole.UserRole)
        by_length_item = TreeItem(self.gui_txt.weight_by_len, 6, set_checkable=True,
                                  color=QtGui.QColor(0, 0, 200))
        by_length_item.setData('RdoItem_Wt', QtCore.Qt.ItemDataRole.UserRole)
        by_angle_item = TreeItem(self.gui_txt.weight_by_angle, 6, set_checkable=True,
                                 color=QtGui.QColor(0, 0, 200))
        by_angle_item.setData('RdoItem_Wt', QtCore.Qt.ItemDataRole.UserRole)
        by_inv_length_item = TreeItem(self.gui_txt.weight_by_inv_len, 6, set_checkable=True,
                                      color=QtGui.QColor(0, 0, 200))
        by_inv_length_item.setData('RdoItem_Wt', QtCore.Qt.ItemDataRole.UserRole)
        by_conductance_item = TreeItem(self.gui_txt.weight_by_var_con, 6, set_checkable=True,
                                       color=QtGui.QColor(0, 0, 200))
        by_conductance_item.setData('RdoItem_Wt', QtCore.Qt.ItemDataRole.UserRole)
        by_resistance_item = TreeItem(self.gui_txt.weight_by_res, 6, set_checkable=True,
                                      color=QtGui.QColor(0, 0, 200))
        by_resistance_item.setData('RdoItem_Wt', QtCore.Qt.ItemDataRole.UserRole)
        weighted_item.appendRow(by_diameter_item)
        weighted_item.appendRow(by_area_item)
        weighted_item.appendRow(by_length_item)
        weighted_item.appendRow(by_angle_item)
        weighted_item.appendRow(by_inv_length_item)
        weighted_item.appendRow(by_conductance_item)
        weighted_item.appendRow(by_resistance_item)

        options_extraction.appendRow(weighted_item)
        # --- end ---

        merge_nearby_item = TreeItem(self.gui_txt.merge, 8, set_checkable=True,
                                     color=QtGui.QColor(0, 0, 200), data=options_gte.merge_nearby_nodes)
        options_extraction.appendRow(merge_nearby_item)

        prune_dangling_item = TreeItem(self.gui_txt.prune, 8, set_checkable=True,
                                       color=QtGui.QColor(0, 0, 200), data=options_gte.prune_dangling_edges)
        options_extraction.appendRow(prune_dangling_item)

        # --- start ---
        remove_disconnected_item = TreeItem(self.gui_txt.remove_disconnected, 8, set_checkable=True,
                                            color=QtGui.QColor(0, 0, 200),
                                            data=options_gte.remove_disconnected_segments)
        remove_size_item = TreeTextItem(str(options_gte.remove_object_size), 8, set_editable=True,
                                        color=QtGui.QColor(0, 0, 200))
        remove_disconnected_item.appendRow(remove_size_item)
        options_extraction.appendRow(remove_disconnected_item)
        # --- end ---

        remove_loops_item = TreeItem(self.gui_txt.remove_loops, 8, set_checkable=True,
                                     color=QtGui.QColor(0, 0, 200), data=options_gte.remove_self_loops)
        options_extraction.appendRow(remove_loops_item)

        is_multigraph_item = TreeItem(self.gui_txt.multigraph, 8, set_checkable=True,
                                      color=QtGui.QColor(0, 0, 200), data=options_gte.is_multigraph)
        options_extraction.appendRow(is_multigraph_item)

        node_id_item = TreeItem(self.gui_txt.node_id, 8, set_checkable=True,
                                color=QtGui.QColor(0, 0, 200), data=options_gte.display_node_id)
        options_extraction.appendRow(node_id_item)

        # 3. Add Computation items
        options_compute = TreeTextItem('Computation Options', 9, set_bold=True, color=QtGui.QColor(128, 0, 0))
        # tree_model.setItem(1, 0, options_compute)  # row, col, item

        heatmaps_item = TreeItem(self.gui_txt.heatmaps, 8, set_checkable=True, color=QtGui.QColor(128, 0, 0),
                                 data=options_gtc.display_heatmaps)
        options_compute.appendRow(heatmaps_item)

        degree_item = TreeItem(self.gui_txt.degree, 8, set_checkable=True, color=QtGui.QColor(128, 0, 0),
                               data=options_gtc.display_degree_histogram)
        options_compute.appendRow(degree_item)

        network_diameter_item = TreeItem(self.gui_txt.diameter, 8, set_checkable=True,
                                         color=QtGui.QColor(128, 0, 0), data=options_gtc.compute_network_diameter)
        options_compute.appendRow(network_diameter_item)

        anc_item = TreeItem(self.gui_txt.connectivity, 8, set_checkable=True,
                            color=QtGui.QColor(128, 0, 0), data=options_gtc.compute_node_connectivity)
        options_compute.appendRow(anc_item)

        clustering_coef_item = TreeItem(self.gui_txt.clustering, 8, set_checkable=True,
                                        color=QtGui.QColor(128, 0, 0), data=options_gtc.compute_clustering_coef)
        options_compute.appendRow(clustering_coef_item)

        assortativity_coef_item = TreeItem(self.gui_txt.assortativity, 8, set_checkable=True,
                                           color=QtGui.QColor(128, 0, 0), data=options_gtc.compute_assortativity_coef)
        options_compute.appendRow(assortativity_coef_item)

        betweenness_centrality_item = TreeItem(self.gui_txt.betweenness, 8, set_checkable=True,
                                               color=QtGui.QColor(128, 0, 0),
                                               data=options_gtc.display_betweenness_histogram)
        options_compute.appendRow(betweenness_centrality_item)

        # current_betweenness_item = TreeItem(self.gui_txt.current_flow, 8, set_checkable=True,
        #                                    color=QtGui.QColor(128, 0, 0),
        #                                    data=options_gtc.display_currentflow_histogram)
        # options_compute.appendRow(current_betweenness_item)

        closeness_centrality_item = TreeItem(self.gui_txt.closeness, 8, set_checkable=True,
                                             color=QtGui.QColor(128, 0, 0),
                                             data=options_gtc.display_closeness_histogram)
        options_compute.appendRow(closeness_centrality_item)

        eigenvector_centrality_item = TreeItem(self.gui_txt.eigenvector, 8, set_checkable=True,
                                               color=QtGui.QColor(128, 0, 0),
                                               data=options_gtc.display_eigenvector_histogram)
        options_compute.appendRow(eigenvector_centrality_item)

        ohms_centrality_item = TreeItem(self.gui_txt.ohms, 8, set_checkable=True,
                                        color=QtGui.QColor(128, 0, 0),
                                        data=options_gtc.display_ohms_histogram)
        options_compute.appendRow(ohms_centrality_item)

        percolation_centrality_item = TreeItem(self.gui_txt.percolation, 8, set_checkable=True,
                                               color=QtGui.QColor(128, 0, 0),
                                               data=options_gtc.display_percolation_histogram)
        options_compute.appendRow(percolation_centrality_item)

        graph_density_item = TreeItem(self.gui_txt.density, 8, set_checkable=True,
                                      color=QtGui.QColor(128, 0, 0), data=options_gtc.compute_graph_density)
        options_compute.appendRow(graph_density_item)

        graph_conductance_item = TreeItem(self.gui_txt.conductance, 8, set_checkable=True,
                                          color=QtGui.QColor(128, 0, 0), data=options_gtc.compute_graph_conductance)
        options_compute.appendRow(graph_conductance_item)

        global_efficiency_item = TreeItem(self.gui_txt.efficiency, 8, set_checkable=True,
                                          color=QtGui.QColor(128, 0, 0), data=options_gtc.compute_global_efficiency)
        options_compute.appendRow(global_efficiency_item)

        wiener_index_item = TreeItem(self.gui_txt.wiener, 8, set_checkable=True,
                                     color=QtGui.QColor(128, 0, 0), data=options_gtc.compute_wiener_index)
        options_compute.appendRow(wiener_index_item)

        # 4. Add Save items
        options_save = TreeTextItem('Save Files', 9, set_bold=True, color=QtGui.QColor(99, 99, 99))
        # tree_model.setItem(2, 0, options_save)  # row, col, item

        export_gexf_item = TreeItem(self.gui_txt.gexf, 8, set_checkable=True,
                                    color=QtGui.QColor(99, 99, 99), data=options_gte.export_as_gexf)
        options_save.appendRow(export_gexf_item)

        export_edge_item = TreeItem(self.gui_txt.edge_list, 8, set_checkable=True,
                                    color=QtGui.QColor(99, 99, 99), data=options_gte.export_edge_list)
        options_save.appendRow(export_edge_item)

        export_adj_item = TreeItem(self.gui_txt.adjacency, 8, set_checkable=True,
                                   color=QtGui.QColor(99, 99, 99), data=options_gte.export_adj_mat)
        options_save.appendRow(export_adj_item)

        save_images_item = TreeItem(self.gui_txt.save_images, 8, set_checkable=True,
                                    color=QtGui.QColor(99, 99, 99), data=options_gte.save_images)
        options_save.appendRow(save_images_item)

        # 5. Append all data
        root_node.appendRow(options_extraction)
        root_node.appendRow(options_compute)
        root_node.appendRow(options_save)
        self.tree_settings.setModel(tree_model)
        # Assign the custom delegate to the second column
        delegate = TreeRadioItemDelegate()
        self.tree_settings.setItemDelegate(delegate)

    def _init_img_filter_settings(self, options_img):
        # Microscopy properties
        self.txt_scalebar_val.setText(str(options_img.scale_value))
        self.txt_scalebar_px.setText(str(options_img.scalebar_px_count))
        self.txt_resistivity.setText(str(options_img.resistivity))

        # range between 0.01-5.0
        self.sld_lut_gamma.setValue(int(options_img.gamma * 100))
        self.lbl_lut_gamma.setText(str(options_img.gamma))

        # must be odd integer
        self.cbx_gaussian_blur.setChecked(options_img.apply_gaussian)
        self.cbx_autolevel.setChecked(options_img.apply_autolevel)
        self.sld_gaussian.setValue(options_img.gaussian_blurring_size)
        self.sld_autolevel.setValue(options_img.autolevel_blurring_size)
        self.lbl_gaussian.setText(str(options_img.gaussian_blurring_size))
        self.lbl_autolevel.setText(str(options_img.autolevel_blurring_size))

        self.cbx_lowpass.setChecked(options_img.apply_lowpass)
        self.spb_lowpass.setValue(options_img.lowpass_window_size)

        self.cbx_laplacian.setChecked(options_img.apply_laplacian)
        self.sld_laplacian.setValue(options_img.laplacian_kernel_size)
        self.lbl_laplacian.setText(str(options_img.laplacian_kernel_size))

        self.cbx_sobel.setChecked(options_img.apply_sobel)
        self.sld_sobel.setValue(options_img.sobel_kernel_size)
        self.lbl_sobel.setText(str(options_img.sobel_kernel_size))

        self.cbx_scharr.setChecked(options_img.apply_scharr)
        self.cbx_median.setChecked(options_img.apply_median)

        # Enhancement
        self.spb_brightness.setValue(options_img.brightness_level)
        self.spb_contrast.setValue(options_img.contrast_level)

        # Listeners
        self.sld_lut_gamma.valueChanged.connect(
            lambda: self.lbl_lut_gamma.setText(str(self.sld_lut_gamma.value() / 100)))
        self.sld_gaussian.valueChanged.connect(lambda: self.lbl_gaussian.setText(
            str(self.sld_gaussian.value() + 1 if self.sld_gaussian.value() % 2 == 0 else self.sld_gaussian.value())))
        self.sld_autolevel.valueChanged.connect(lambda: self.lbl_autolevel.setText(
            str(self.sld_autolevel.value() + 1 if self.sld_autolevel.value() % 2 == 0 else self.sld_autolevel.value())))
        self.sld_laplacian.valueChanged.connect(lambda: self.lbl_laplacian.setText(
            str(self.sld_laplacian.value() + 1 if self.sld_laplacian.value() % 2 == 0 else self.sld_laplacian.value())))
        self.sld_sobel.valueChanged.connect(lambda: self.lbl_sobel.setText(
            str(self.sld_sobel.value() + 1 if self.sld_sobel.value() % 2 == 0 else self.sld_sobel.value())))

        # Filter Listeners
        self.spb_brightness.valueChanged.connect(self._image_filters_changed)
        self.spb_contrast.valueChanged.connect(self._image_filters_changed)

        self.lbl_lut_gamma.textChanged.connect(self._image_filters_changed)
        self.cbx_gaussian_blur.stateChanged.connect(self._image_filters_changed)
        self.cbx_autolevel.stateChanged.connect(self._image_filters_changed)
        self.lbl_gaussian.textChanged.connect(self._image_filters_changed)
        self.lbl_autolevel.textChanged.connect(self._image_filters_changed)
        self.cbx_lowpass.stateChanged.connect(self._image_filters_changed)
        self.spb_lowpass.valueChanged.connect(self._image_filters_changed)
        self.cbx_laplacian.stateChanged.connect(self._image_filters_changed)
        self.lbl_laplacian.textChanged.connect(self._image_filters_changed)
        self.cbx_sobel.stateChanged.connect(self._image_filters_changed)
        self.lbl_sobel.textChanged.connect(self._image_filters_changed)
        self.cbx_scharr.stateChanged.connect(self._image_filters_changed)
        self.cbx_median.stateChanged.connect(self._image_filters_changed)

    def _init_img_binary_settings(self, options_img):

        if options_img.image_dimensions == 3:
            self.rdo_3d_img.setChecked(True)
        else:
            self.rdo_2d_img.setChecked(True)

        if options_img.threshold_type == 2:
            self.rdo_otsu_threshold.setChecked(True)
        elif options_img.threshold_type == 1:
            self.rdo_adaptive_threshold.setChecked(True)
        else:
            self.rdo_global_threshold.setChecked(True)

        # range between 1-255
        self.sld_global_threshold.setValue(options_img.threshold_global)
        self.lbl_global_threshold_value.setText(str(options_img.threshold_global))

        # must be odd integer
        self.spb_adaptive_threshold_val = options_img.threshold_adaptive
        self.spb_adaptive_threshold.setValue(options_img.threshold_adaptive)
        self.cbx_dark_foreground.setChecked(options_img.apply_dark_foreground)

        # Listeners
        self.sld_global_threshold.valueChanged.connect(
            lambda: self.lbl_global_threshold_value.setText(str(self.sld_global_threshold.value())))

        # Filter Listeners
        self.rdo_otsu_threshold.toggled.connect(self._image_filters_changed)
        self.rdo_adaptive_threshold.toggled.connect(self._image_filters_changed)
        self.rdo_global_threshold.toggled.connect(self._image_filters_changed)
        self.lbl_global_threshold_value.textChanged.connect(self._image_filters_changed)
        self.spb_adaptive_threshold.valueChanged.connect(self._image_filters_changed)
        self.cbx_dark_foreground.stateChanged.connect(self._image_filters_changed)

    def _init_img_path_settings(self, options):
        self.cbx_multi.setChecked(options.multiImage)
        if self.txt_img_path.text() == '':
            self.lbl_img.setText("Add 'Image Path' using the 'Select' button")

        # Listeners
        self.rdo_2d_img.toggled.connect(self._rdo_image_dimensions_changed)
        self.rdo_3d_img.toggled.connect(self._rdo_image_dimensions_changed)
        self.btn_select_img_path.clicked.connect(self._btn_select_img_path_clicked)
        self.btn_select_out_path.clicked.connect(self._btn_select_out_path_clicked)
        self.cbx_multi.stateChanged.connect(self._cbx_multi_changed)
        self.btn_next.clicked.connect(self._btn_next_clicked)
        self.btn_prev.clicked.connect(self._btn_prev_clicked)
        self.btn_zoom_in.clicked.connect(self._btn_zoom_in_clicked)
        self.btn_zoom_out.clicked.connect(self._btn_zoom_out_clicked)
        self.enable_path_only()

    def _init_tools(self):
        self.btn_cancel.setEnabled(False)

        self.btn_about.clicked.connect(MainUI._btn_about_clicked)
        self.btn_cancel.clicked.connect(self._btn_cancel_clicked)
        self.btn_crop.clicked.connect(self._btn_crop_clicked)
        # self.btn_reset_filters.clicked.connect(self._btn_reset_filters_clicked)
        self.cb_show_img.currentIndexChanged.connect(self._cb_show_img_changed)
        self.btn_show_graph.clicked.connect(self._btn_show_graph_clicked)
        self.btn_quick_graph_metrics.clicked.connect(self._btn_quick_metrics_clicked)
        self.btn_save_files.clicked.connect(self._btn_save_files_clicked)
        self.btn_gt_metrics.clicked.connect(self._btn_compute_gt_metrics_clicked)
        self.btn_gt_metrics_all.clicked.connect(self._btn_compute_gt_metrics_all_clicked)
        # self.btn_chaos_gt.clicked.connect(self._btn_chaos_gt_clicked)

    @staticmethod
    def _btn_about_clicked():
        about = ("\n"
                 "A software tool that allows graph theory analysis \n"
                 "of nano-structures. This is a modified version of \n"
                 "StructuralGT initially proposed by Drew A. Vecchio.\n\n"
                 "DOI: 10.1021/acsnano.1c04711"
                 "\n")
        dialog = CustomDialog("About StructuralGT", about)
        dialog.exec()
        return

    def _spb_adaptive_threshold_value_changed(self):
        val = self.spb_adaptive_threshold.value()
        if val % 2 == 0:
            if val < 1:
                self.spb_adaptive_threshold.setValue(1)
            elif val > self.spb_adaptive_threshold_val:
                self.spb_adaptive_threshold.setValue(val + 1)
                self.spb_adaptive_threshold_val = (val + 1)
            else:
                self.spb_adaptive_threshold.setValue(val - 1)
                self.spb_adaptive_threshold_val = (val - 1)
        else:
            self.spb_adaptive_threshold.setValue(val)

    def _btn_cancel_clicked(self):
        # Quit the thread to stop any ongoing tasks
        if self.worker.isRunning():
            self.worker.send_abort_message()
            self.error_flag = True
            self.lbl_progress.setText("Please wait, aborting...")

    def _btn_reset_filters_clicked(self):
        if self.txt_img_path.text() == '':
            dialog = CustomDialog("File Error", "Add 'Image Path' using the 'Select' button")
            dialog.exec()
            return
        else:
            self.configs_data = load_configs()
            # options = configs_data['main_options']
            options_img = self.configs_data['filter_options']
            options_gte = self.configs_data['extraction_options']
            options_gtc = self.configs_data['sgt_options']

            self._init_tree(options_gte, options_gtc)
            self._init_img_filter_settings(options_img)
            self._init_img_binary_settings(options_img)
            # self._reload_ui()

    def _cbx_multi_changed(self):
        if self.txt_img_path.text() == '':
            return

        if self.cbx_multi.isChecked() and os.path.isfile(self.txt_img_path.text()):
            # split the file location into file name and path
            img_dim = self.configs_data['filter_options']['image_dimensions']
            img_dir, file_name = os.path.split(self.txt_img_path.text())

            files = os.listdir(img_dir)
            files = sorted(files)

            self.graph_objs = []
            for a_file in files:
                if a_file.endswith(('.tif', '.png', '.jpg', '.jpeg')):
                    file_name = os.path.join(img_dir, a_file)
                    im_obj = ImageProcessor(file_name, '', img_dim)
                    obj = GraphConverter(im_obj)
                    self.graph_objs.append(obj)
            if len(self.graph_objs) <= 0:
                dialog = CustomDialog("File Error",
                                      "No workable images found! Files have to be either .tif, .png, or .jpg")
                dialog.exec()
            self._reload_ui()
        else:
            self.graph_objs = [self.graph_objs[0]]
            self._reload_ui()

    def _rdo_image_dimensions_changed(self):
        options_img = self.configs_data['filter_options']
        img_dim_type = self.btn_grp_img.checkedButton()

        if img_dim_type == self.rdo_2d_img:
            options_img.image_dimensions = 2
        elif img_dim_type == self.rdo_3d_img:
            options_img.image_dimensions = 3
        self.enable_path_controls()

    def _btn_select_img_path_clicked(self):
        img_dim = self.configs_data['filter_options']['image_dimensions']
        if self.cbx_multi.isChecked():
            fd_image_dir = QtWidgets.QFileDialog.getExistingDirectory(self, 'Select Folder')
            if fd_image_dir:
                files = os.listdir(fd_image_dir)
                files = sorted(files)

                self.graph_objs = []
                for a_file in files:
                    if a_file.endswith(('.tif', '.png', '.jpg', '.jpeg')):
                        file_name = os.path.join(fd_image_dir, a_file)
                        im_obj = ImageProcessor(file_name, '', img_dim)
                        obj = GraphConverter(im_obj)
                        self.graph_objs.append(obj)
                if len(self.graph_objs) <= 0:
                    dialog = CustomDialog("File Error",
                                          "No workable images found! Files have to be either .tif, .png, or .jpg")
                    dialog.exec()
        else:
            fd_image_file, _ = QtWidgets.QFileDialog.getOpenFileName(self, 'Open file',
                                                                     filter="Image files (*.jpg *.tif *.png *.jpeg)")
            if fd_image_file:
                self.graph_objs = []
                # split the file location into path and file name
                fd_image_dir, _ = os.path.split(fd_image_file)
                im_obj = ImageProcessor(fd_image_file, '', img_dim)
                obj = GraphConverter(im_obj)
                self.graph_objs.append(obj)
        # Set and display image
        self._reload_ui()

    def _btn_select_out_path_clicked(self):
        fd_out_dir = QtWidgets.QFileDialog.getExistingDirectory(self, 'Select Folder')
        self.txt_out_path.setText(fd_out_dir)

    def _btn_next_clicked(self):
        if self.current_obj_index < (len(self.graph_objs) - 1):
            self.current_obj_index += 1
            self._load_image('O')

            self.btn_prev.setEnabled(True)
            if self.current_obj_index == (len(self.graph_objs) - 1):
                self.btn_next.setEnabled(False)
        else:
            self.btn_next.setEnabled(False)

    def _btn_prev_clicked(self):
        if self.current_obj_index > 0:
            self.current_obj_index -= 1
            self._load_image('O')

            self.btn_next.setEnabled(True)
            if self.current_obj_index == 0:
                self.btn_prev.setEnabled(False)
        else:
            self.btn_prev.setEnabled(False)

    def _btn_zoom_in_clicked(self):
        if self.img_scale < 1:
            self.img_scale = 1
        else:
            self.img_scale *= 1.05
        self._rescale_pixmap()

    def _btn_zoom_out_clicked(self):
        if self.img_scale > 1:
            self.img_scale = 1
        else:
            self.img_scale /= 1.05
        self._rescale_pixmap()

    def _btn_crop_clicked(self):
        try:
            g_obj = self.graph_objs[self.current_obj_index]
            img = Image.fromarray(g_obj.imp.img)
            q_img = ImageQt.toqpixmap(img)
            crop_tool = QCrop(q_img, self)
            status = crop_tool.exec()
            if status == crop_tool.DialogCode.Accepted:
                try:
                    q_img = crop_tool.image.toImage()
                    img_pil = ImageQt.fromqimage(q_img)
                    img_crop = ImageProcessor.load_img_from_pil(img_pil)
                    g_obj.imp.img, g_obj.imp.scale_factor = ImageProcessor.resize_img(512, img_crop)
                    g_obj.reset()
                    self._load_image('O')
                except Exception as err:
                    print(err)
                    logging.exception("Cropping Error: %s", err, extra={'user': 'SGT Logs'})
                    dialog = CustomDialog("Cropping Error", "Unable to crop image! Try again.")
                    dialog.exec()
        except IndexError:
            dialog = CustomDialog("File Error", "Add new 'Image Path' using the 'Select' button")
            dialog.exec()

    def _cb_show_img_changed(self):
        try:
            img_idx = self.cb_show_img.currentIndex()
            if img_idx == 0:
                g_obj = self.graph_objs[self.current_obj_index]
                img = Image.fromarray(g_obj.imp.img)
                q_img = ImageQt.toqpixmap(img)
                self._load_image('O', q_img)
            elif img_idx == 1:
                g_obj = self.graph_objs[self.current_obj_index]
                if g_obj.imp.img_mod is not None:
                    img = Image.fromarray(g_obj.imp.img_mod)
                    q_img = ImageQt.toqpixmap(img)
                    self._load_image('M', q_img)
                else:
                    self._image_filters_changed()
            elif img_idx == 2:
                g_obj = self.graph_objs[self.current_obj_index]
                if g_obj.imp.img_bin is not None:
                    img = Image.fromarray(g_obj.imp.img_bin)
                    q_img = ImageQt.toqpixmap(img)
                    self._load_image('B', q_img)
                else:
                    self.current_img = 'B'
                    self._image_filters_changed()
        except IndexError:
            dialog = CustomDialog("File Error", "Add new 'Image Path' using the 'Select' button")
            dialog.exec()

    def _btn_show_graph_clicked(self):
        try:
            self.wait_flag = True
            g_obj = self.graph_objs[self.current_obj_index]
            if g_obj.imp.img_net is not None:
                q_img = ImageQt.toqpixmap(g_obj.imp.img_net)
                self._load_image('G', q_img)
                self.wait_flag = False
            else:
                self.disable_all_tasks()
                options_img = self._fetch_img_options()
                options_gte = self._fetch_gte_options()

                self.worker = Worker(func_id=1, args=(g_obj, options_img, options_gte))
                self.worker.signals.progress.connect(self._handle_progress_update)
                self.worker.signals.finished.connect(self._handle_finished)
                self.worker.start()
        except IndexError:
            self.error_flag = True
            self.wait_flag = False
            self.enable_all_tasks()
            dialog = CustomDialog("File Error", "Add new 'Image Path' using the 'Select' button")
            dialog.exec()

    def _btn_quick_metrics_clicked(self):
        try:
            g_obj = self.graph_objs[self.current_obj_index]
            if g_obj.nx_graph is not None:
                info = ""
                info += "Number of nodes: " + str(int(g_obj.nx_graph.number_of_nodes())) + "\n"
                info += "Number of edges: " + str(int(g_obj.nx_graph.number_of_edges())) + "\n"
                info += "Number of sub-graphs: " + str(len(g_obj.nx_components)) + "\n"
                info += "Largest-entire graph ratio: " + str(round((g_obj.connect_ratio * 100), 3)) + "%" + "\n"

                dialog = CustomDialog("Graph Network Details", info)
                dialog.exec()
            else:
                dialog = CustomDialog("Graph Error", "First click on 'Show Graph'...")
                dialog.exec()
        except IndexError:
            dialog = CustomDialog("File Error", "Add new 'Image Path' using the 'Select' button")
            dialog.exec()

    def _btn_save_files_clicked(self):
        try:
            self.wait_flag = True
            self.disable_all_tasks()
            g_obj = self.graph_objs[self.current_obj_index]
            if (g_obj.nx_graph is not None) and (g_obj.imp.img_path != ''):
                options_file = self._fetch_save_options()
                try:
                    g_obj.save_files(options_file)
                    dialog = CustomDialog("Success", "All files saved in 'Output Dir'")
                    dialog.exec()
                except Exception as err:
                    print(err)
                    logging.exception("Save Files Error: %s", err, extra={'user': 'SGT Logs'})
                    dialog = CustomDialog("File Save Error", "Unable to save files! Try again.")
                    dialog.exec()
            else:
                dialog = CustomDialog("Graph Error", "First click on 'Show Graph'...")
                dialog.exec()
            self.wait_flag = False
            self.enable_all_tasks()
        except IndexError:
            self.error_flag = True
            self.wait_flag = False
            self.enable_all_tasks()
            dialog = CustomDialog("File Error", "Add new 'Image Path' using the 'Select' button")
            dialog.exec()

    def _btn_compute_gt_metrics_clicked(self):
        try:
            self.wait_flag = True
            g_obj = self.graph_objs[self.current_obj_index]
            g_obj.imp.output_path = self.txt_out_path.text()
            self.disable_all_tasks()
            options_img = self._fetch_img_options()
            options_gte = self._fetch_gte_options()
            options_gtc = self._fetch_gtc_options()

            # worker = Worker(func_id=1, args=(img_path, output_path, options_img, options_gte, img))
            # worker.signals.progress.connect(self._handle_progress_update)
            # worker.signals.finished.connect(self._handle_finished)
            # self.threadpool.start(worker)

            self.worker = Worker(func_id=2, args=(g_obj, options_img, options_gte, options_gtc))
            self.worker.signals.progress.connect(self._handle_progress_update)
            self.worker.signals.finished.connect(self._handle_finished)
            self.worker.start()
        except IndexError:
            self.error_flag = True
            self.wait_flag = False
            self.enable_all_tasks()
            dialog = CustomDialog("File Error", "Add new 'Image Path' using the 'Select' button")
            dialog.exec()

    def _btn_compute_gt_metrics_all_clicked(self):
        self.wait_flag = True
        self.disable_all_tasks()
        options_img = self._fetch_img_options()
        options_gte = self._fetch_gte_options()
        options_gtc = self._fetch_gtc_options()
        out_path = self.txt_out_path.text()

        self.worker = Worker(func_id=3, args=(self.graph_objs, out_path, options_img, options_gte, options_gtc))
        self.worker.signals.progress.connect(self._handle_progress_update)
        self.worker.signals.finished.connect(self._handle_finished)
        self.worker.start()

        self.current_obj_index = 0
        self._load_image('O')
        self.lbl_info.setText(f"processing image {(self.current_obj_index + 1)} of {len(self.graph_objs)}")

    def _handle_finished(self, task: int, show_dialog: int, obj):
        """
        Listen and handle control when worker threads complete execution.

        :param task:
        :param show_dialog:
        :param obj:
        :return:
        """
        # if (task == 0) and (not self.error_flag):
        #    try:
        #        self.graph_objs[self.current_obj_index].imp = obj
        #        img = Image.fromarray(obj.img_bin)
        #        q_img = ImageQt.toqpixmap(img)
        #        self._load_image('B', q_img)
        #    except Exception as err:
        #        print(err)
        #        logging.exception("Error: %s", err, extra={'user': 'SGT Logs'})
        #    self._handle_progress_update(100, 100, "Image filters applied.")
        if (task == 1) and (not self.error_flag):
            try:
                self.graph_objs[self.current_obj_index] = obj
                q_img = ImageQt.toqpixmap(obj.imp.img_net)
                self._load_image('G', q_img)
                self._handle_progress_update(100, 100, "Drawing graph complete!")
                if show_dialog == 1:
                    dialog = CustomDialog("Success!", 'Graph network ready.')
                    dialog.exec()
            except Exception as err:
                print(err)
                logging.exception("Error: %s", err, extra={'user': 'SGT Logs'})
                self.error_flag = True
        elif (task == 2) and (not self.error_flag):
            try:
                plot_data = obj
                self.write_gt_pdf(plot_data)
                self._handle_progress_update(100, 100, "GT PDF successfully generated!")
                if show_dialog == 1:
                    self.wait_flag = False
                    self.enable_all_tasks()
                    dialog = CustomDialog("Success!",
                                          "GT calculations completed. Check out generated PDF in 'Output Dir'")
                    dialog.exec()
                else:
                    if (self.current_obj_index + 1) < len(self.graph_objs):
                        self.current_obj_index += 1
                        self.lbl_info.setText(
                            f"processing image {(self.current_obj_index + 1)} of {len(self.graph_objs)}")
                        self._load_image('O')
            except Exception as err:
                print(err)
                logging.exception("Error: %s", err, extra={'user': 'SGT Logs'})
                self.error_flag = True
        elif task == 3 and (not self.error_flag):
            dialog = CustomDialog("Success!", "GT calculations completed. Check out generated PDFs in 'Output Dir'")
            dialog.exec()
        elif task == 4 and (not self.error_flag):
            self._handle_progress_update(100, 100, obj)

        if (task != 2) or self.error_flag:
            self.wait_flag = False
            self.enable_all_tasks()

    def _handle_progress_update(self, value: int, code: int, msg: str):
        """
        Update progress of worker thread.

        :param value:
        :param code:
        :param msg:
        :return:
        """
        print(str(value) + "%: " + msg)
        logging.info(str(value) + "%: " + msg, extra={'user': 'SGT Logs'})
        if (code > 0) and (not self.error_flag):
            self.lbl_progress.setStyleSheet("color: rgb(0, 128, 0)")
            self.lbl_progress.setText(msg)
            self.progress_bar_main.setValue(value)
        else:
            self.error_flag = True
            self.lbl_progress.setStyleSheet("color: rgb(255, 0, 0)")
            self.lbl_progress.setText("ERROR: " + str(msg))
            self.progress_bar_main.setValue(0)
            dialog = CustomDialog("Error", msg)
            dialog.exec()

    def _image_filters_changed(self):
        """
        Apply filters selected by user to image.

        :return:
        """
        if self.wait_flag:
            dialog = CustomDialog("Please wait...", "Another task is running.")
            dialog.exec()
        else:
            try:
                self.disable_all_tasks()
                self._spb_adaptive_threshold_value_changed()

                self.graph_objs[self.current_obj_index].reset()
                im_obj = self.graph_objs[self.current_obj_index].imp
                im_obj.output_path = self.txt_out_path.text()
                im_obj.configs_img = self._fetch_img_options()
                im_obj.img_mod = im_obj.process_img(im_obj.img.copy())

                if self.current_img == 'B':
                    im_obj.img_bin, im_obj.otsu_val = im_obj.binarize_img(im_obj.img_mod.copy())
                    img = Image.fromarray(im_obj.img_bin)
                    q_img = ImageQt.toqpixmap(img)
                    self._load_image('B', q_img)
                else:
                    img = Image.fromarray(im_obj.img_mod)
                    q_img = ImageQt.toqpixmap(img)
                    self._load_image('M', q_img)
                self.enable_all_tasks()
            except IndexError:
                self.error_flag = True
                self.enable_all_tasks()
                dialog = CustomDialog("File Error", "Add new 'Image Path' using the 'Select' button")
                dialog.exec()

    def _reload_ui(self):
        """
        Reload image UI when user resets.

        :return:
        """
        # Set and display image
        if len(self.graph_objs) > 0:
            self.current_obj_index = 0
            self._load_image('O')
            self.enable_all_tasks()

            if len(self.graph_objs) > 1:
                self.btn_next.setEnabled(True)
                self.btn_prev.setEnabled(False)
                if self.btn_gt_metrics.isEnabled():
                    self.btn_gt_metrics_all.setEnabled(True)
                else:
                    self.btn_gt_metrics_all.setEnabled(False)
            else:
                self.btn_next.setEnabled(False)
                self.btn_prev.setEnabled(False)
                self.btn_gt_metrics_all.setEnabled(False)
        else:
            self._load_image('O')
            self.enable_path_only()

    def _load_image(self, current_img, img_pixmap=None):
        """
        Load and display image on UI.

        :param current_img:
        :param img_pixmap:
        :return:
        """
        self.img_scale = 1
        self.current_img = current_img
        self.lbl_img.setText('')
        self.lbl_info.setText(f"image {(self.current_obj_index + 1)} of {len(self.graph_objs)}")

        w = self.lbl_img.width()
        h = self.lbl_img.height()
        if img_pixmap is None:
            try:
                g_obj = self.graph_objs[self.current_obj_index]
                self._cb_show_img_changed()

                self.txt_img_path.setText(g_obj.imp.img_path)
                if self.txt_out_path.text() == '':
                    img_dir, _ = os.path.split(g_obj.imp.img_path)
                    self.txt_out_path.setText(img_dir)
            except IndexError as err:
                self.txt_img_path.setText('')
                self.txt_out_path.setText('')
                self.lbl_img.setPixmap(QtGui.QPixmap())
                # print(err)
                logging.exception("Index Error: %s", err, extra={'user': 'SGT Logs'})
        else:
            self.lbl_img.setPixmap(img_pixmap.scaled(w, h, QtCore.Qt.AspectRatioMode.KeepAspectRatio))

    def _rescale_pixmap(self):
        """
        Apply zoom scales to image.

        :return:
        """
        img_pixmap = self.lbl_img.pixmap()
        size = img_pixmap.size()
        self.lbl_img.setPixmap(img_pixmap.scaled((self.img_scale * size)))

    def _fetch_img_options(self):
        """
        Load image filter options and parameters.

        :return:
        """
        options_img = self.configs_data['filter_options']

        bin_btn_type = self.btn_grp_binary.checkedButton()
        if bin_btn_type == self.rdo_otsu_threshold:
            options_img.threshold_type = 2
        elif bin_btn_type == self.rdo_adaptive_threshold:
            options_img.threshold_type = 1
        else:
            options_img.threshold_type = 0

        try:
            options_img.scale_value = float(self.txt_scalebar_val.text())
            options_img.scalebar_px_count = int(self.txt_scalebar_px.text())
            options_img.resistivity = float(self.txt_resistivity.text())
        except ValueError:
            dialog = CustomDialog("Input Error!",
                                  "Please enter only numbers in the 'Microscopy Properties' section.")
            dialog.exec()

        options_img.threshold_global = int(self.lbl_global_threshold_value.text())
        options_img.threshold_adaptive = int(self.spb_adaptive_threshold.text())
        options_img.gamma = float(self.lbl_lut_gamma.text())
        options_img.gaussian_blurring_size = int(self.lbl_gaussian.text())
        options_img.autolevel_blurring_size = int(self.lbl_autolevel.text())
        options_img.lowpass_window_size = int(self.spb_lowpass.text())
        options_img.laplacian_kernel_size = int(self.lbl_laplacian.text())
        options_img.sobel_kernel_size = int(self.lbl_sobel.text())
        options_img.apply_autolevel = int(self.cbx_autolevel.isChecked())
        options_img.apply_laplacian = int(self.cbx_laplacian.isChecked())
        options_img.apply_scharr = int(self.cbx_scharr.isChecked())
        options_img.apply_sobel = int(self.cbx_sobel.isChecked())
        options_img.apply_median = int(self.cbx_median.isChecked())
        options_img.apply_gaussian = int(self.cbx_gaussian_blur.isChecked())
        options_img.apply_lowpass = int(self.cbx_lowpass.isChecked())
        options_img.apply_dark_foreground = int(self.cbx_dark_foreground.isChecked())
        options_img.brightness_level = int(self.spb_brightness.text())
        options_img.contrast_level = int(self.spb_contrast.text())
        return options_img

    def _fetch_gte_options(self):
        """
        Load graph extraction options and parameters.

        :return:
        """

        options_gte = self.configs_data['extraction_options']

        # Reset all parameter options
        options_gte.merge_nearby_nodes = 0
        options_gte.prune_dangling_edges = 0
        options_gte.remove_disconnected_segments = 0
        options_gte.remove_self_loops = 0
        options_gte.is_multigraph = 0
        options_gte.has_weights = 0
        options_gte.weight_type = 'DIA'
        options_gte.display_node_id = 0

        weight_options = {
            self.gui_txt.weight_by_dia: 'DIA',
            self.gui_txt.weight_by_area: 'AREA',
            self.gui_txt.weight_by_len: 'LEN',
            self.gui_txt.weight_by_angle: 'ANGLE',
            self.gui_txt.weight_by_inv_len: 'INV_LEN',
            self.gui_txt.weight_by_var_con: 'VAR_CON',
            # self.gui_txt.weight_by_fix_con: 'FIX_CON',
            self.gui_txt.weight_by_res: 'RES',
            # '': ''
        }

        model = self.tree_settings.model()
        root_index = model.index(0, 0)  # Assuming the root index is at row 0, column 0
        for i in range(model.rowCount(root_index)):
            child_index = model.index(i, 0, root_index)
            item = model.itemFromIndex(child_index)
            if item.isCheckable() and item.checkState() == QtCore.Qt.CheckState.Checked:
                if item.text() == self.gui_txt.merge:
                    options_gte.merge_nearby_nodes = 1
                if item.text() == self.gui_txt.prune:
                    options_gte.prune_dangling_edges = 1
                if item.text() == self.gui_txt.remove_disconnected:
                    options_gte.remove_disconnected_segments = 1
                    sub_item = item.child(0)
                    options_gte.remove_object_size = int(sub_item.text())
                if item.text() == self.gui_txt.remove_loops:
                    options_gte.remove_self_loops = 1
                if item.text() == self.gui_txt.multigraph:
                    options_gte.is_multigraph = 1
                if item.text() == self.gui_txt.weighted:
                    options_gte.has_weights = 1
                    # sub_items = item.
                    if item.child(0).checkState() == QtCore.Qt.CheckState.Checked:
                        options_gte.weight_type = weight_options.get(item.child(0).text())
                    elif item.child(1).checkState() == QtCore.Qt.CheckState.Checked:
                        options_gte.weight_type = weight_options.get(item.child(1).text())
                    elif item.child(2).checkState() == QtCore.Qt.CheckState.Checked:
                        options_gte.weight_type = weight_options.get(item.child(2).text())
                    elif item.child(3).checkState() == QtCore.Qt.CheckState.Checked:
                        options_gte.weight_type = weight_options.get(item.child(3).text())
                    elif item.child(4).checkState() == QtCore.Qt.CheckState.Checked:
                        options_gte.weight_type = weight_options.get(item.child(4).text())
                    elif item.child(5).checkState() == QtCore.Qt.CheckState.Checked:
                        options_gte.weight_type = weight_options.get(item.child(5).text())
                    # print(f"weight type: {options_gte.weight_type}")
                if item.text() == self.gui_txt.node_id:
                    options_gte.display_node_id = 1

        root_index = model.index(2, 0)
        child_index = model.index(0, 0, root_index)
        item = model.itemFromIndex(child_index)
        if item.isCheckable() and item.checkState() == QtCore.Qt.CheckState.Checked:
            if item.text() == self.gui_txt.gexf:
                options_gte.export_as_gexf = 1

        child_index = model.index(1, 0, root_index)
        item = model.itemFromIndex(child_index)
        if item.isCheckable() and item.checkState() == QtCore.Qt.CheckState.Checked:
            if item.text() == self.gui_txt.edge_list:
                options_gte.export_edge_list = 1

        child_index = model.index(2, 0, root_index)
        item = model.itemFromIndex(child_index)
        if item.isCheckable() and item.checkState() == QtCore.Qt.CheckState.Checked:
            if item.text() == self.gui_txt.adjacency:
                options_gte.export_adj_mat = 1

        child_index = model.index(3, 0, root_index)
        item = model.itemFromIndex(child_index)
        if item.isCheckable() and item.checkState() == QtCore.Qt.CheckState.Checked:
            if item.text() == self.gui_txt.save_images:
                options_gte.save_images = 1
        return options_gte

    def _fetch_gtc_options(self):
        """
        Load GT computation options and parameters.
        :return:
        """
        options_gtc = self.configs_data['sgt_options']

        # Reset all parameter options
        options_gtc.display_heatmaps = 0
        options_gtc.display_degree_histogram = 0
        options_gtc.display_betweenness_histogram = 0
        options_gtc.display_currentflow_histogram = 0
        options_gtc.display_closeness_histogram = 0
        options_gtc.display_eigenvector_histogram = 0
        options_gtc.display_ohms_histogram = 0
        options_gtc.display_percolation_histogram = 0
        options_gtc.compute_node_connectivity = 0
        options_gtc.compute_graph_density = 0
        options_gtc.compute_graph_conductance = 0
        options_gtc.compute_global_efficiency = 0
        options_gtc.compute_clustering_coef = 0
        options_gtc.compute_assortativity_coef = 0
        options_gtc.compute_network_diameter = 0
        options_gtc.compute_wiener_index = 0

        if self.cbx_igraph.isChecked():
            options_gtc.compute_lang = 'C'
        else:
            options_gtc.compute_lang = 'Py'

        model = self.tree_settings.model()
        root_index = model.index(1, 0)  # Assuming the root index is at row 0, column 0
        for i in range(model.rowCount(root_index)):
            child_index = model.index(i, 0, root_index)
            item = model.itemFromIndex(child_index)
            if item.isCheckable() and item.checkState() == QtCore.Qt.CheckState.Checked:
                if item.text() == self.gui_txt.heatmaps:
                    options_gtc.display_heatmaps = 1
                if item.text() == self.gui_txt.degree:
                    options_gtc.display_degree_histogram = 1
                if item.text() == self.gui_txt.betweenness:
                    options_gtc.display_betweenness_histogram = 1
                if item.text() == '':
                    options_gtc.display_currentflow_histogram = 1
                if item.text() == self.gui_txt.closeness:
                    options_gtc.display_closeness_histogram = 1
                if item.text() == self.gui_txt.eigenvector:
                    options_gtc.display_eigenvector_histogram = 1
                if item.text() == self.gui_txt.ohms:
                    options_gtc.display_ohms_histogram = 1
                if item.text() == self.gui_txt.percolation:
                    options_gtc.display_percolation_histogram = 1
                if item.text() == self.gui_txt.connectivity:
                    options_gtc.compute_node_connectivity = 1
                if item.text() == self.gui_txt.density:
                    options_gtc.compute_graph_density = 1
                if item.text() == self.gui_txt.conductance:
                    options_gtc.compute_graph_conductance = 1
                if item.text() == self.gui_txt.efficiency:
                    options_gtc.compute_global_efficiency = 1
                if item.text() == self.gui_txt.clustering:
                    options_gtc.compute_clustering_coef = 1
                if item.text() == self.gui_txt.assortativity:
                    options_gtc.compute_assortativity_coef = 1
                if item.text() == self.gui_txt.diameter:
                    options_gtc.compute_network_diameter = 1
                if item.text() == self.gui_txt.wiener:
                    options_gtc.compute_wiener_index = 1
        return options_gtc

    def _fetch_save_options(self):
        """
        Load file save options.
        :return:
        """
        options_file = struct()
        # options_gte = self.configs_data['extraction_options']

        options_file.export_edge_list = 0
        options_file.export_as_gexf = 0
        options_file.export_adj_mat = 0
        options_file.save_images = 0

        model = self.tree_settings.model()
        root_index = model.index(2, 0)
        child_index = model.index(0, 0, root_index)
        item = model.itemFromIndex(child_index)
        if item.isCheckable() and item.checkState() == QtCore.Qt.CheckState.Checked:
            if item.text() == self.gui_txt.gexf:
                options_file.export_as_gexf = 1

        child_index = model.index(1, 0, root_index)
        item = model.itemFromIndex(child_index)
        if item.isCheckable() and item.checkState() == QtCore.Qt.CheckState.Checked:
            if item.text() == self.gui_txt.edge_list:
                options_file.export_edge_list = 1

        child_index = model.index(2, 0, root_index)
        item = model.itemFromIndex(child_index)
        if item.isCheckable() and item.checkState() == QtCore.Qt.CheckState.Checked:
            if item.text() == self.gui_txt.adjacency:
                options_file.export_adj_mat = 1

        child_index = model.index(3, 0, root_index)
        item = model.itemFromIndex(child_index)
        if item.isCheckable() and item.checkState() == QtCore.Qt.CheckState.Checked:
            if item.text() == self.gui_txt.save_images:
                options_file.save_images = 1
        return options_file

    def disable_all_tasks(self):
        """
        Disable all buttons and controls.

        :return:
        """
        self.error_flag = False
        self.btn_cancel.setEnabled(True)  # Opposite of others

        self.disable_path_controls()
        self.disable_img_tasks()
        self.disable_filter_controls()

    def disable_path_controls(self):
        """Disable all path controls and buttons."""
        self.rdo_2d_img.setEnabled(False)
        self.rdo_3d_img.setEnabled(False)
        self.btn_select_img_path.setEnabled(False)
        self.btn_select_out_path.setEnabled(False)
        self.cbx_multi.setEnabled(False)

    def disable_img_tasks(self):
        """Disable GT controls and buttons."""
        self.btn_zoom_in.setEnabled(False)
        self.btn_zoom_out.setEnabled(False)
        self.btn_next.setEnabled(False)
        self.btn_prev.setEnabled(False)

        # self.btn_reset_filters.setEnabled(False)
        self.btn_crop.setEnabled(False)
        self.spb_contrast.setEnabled(False)
        self.spb_brightness.setEnabled(False)

        self.cb_show_img.setEnabled(False)
        self.btn_show_graph.setEnabled(False)
        self.btn_quick_graph_metrics.setEnabled(False)
        self.btn_save_files.setEnabled(False)

        self.cbx_igraph.setEnabled(False)
        self.btn_gt_metrics.setEnabled(False)
        self.btn_gt_metrics_all.setEnabled(False)
        # self.btn_chaos_gt.setEnabled(False)

    def disable_filter_controls(self):
        """Disable all filter controls"""
        self.txt_scalebar_val.setEnabled(False)
        self.txt_scalebar_px.setEnabled(False)
        self.txt_resistivity.setEnabled(False)

        self.spb_brightness.setEnabled(False)
        self.spb_contrast.setEnabled(False)

        self.sld_lut_gamma.setEnabled(False)
        self.cbx_gaussian_blur.setEnabled(False)
        self.sld_gaussian.setEnabled(False)
        self.cbx_autolevel.setEnabled(False)
        self.sld_autolevel.setEnabled(False)
        self.cbx_laplacian.setEnabled(False)
        self.sld_laplacian.setEnabled(False)
        self.cbx_sobel.setEnabled(False)
        self.sld_sobel.setEnabled(False)
        self.cbx_lowpass.setEnabled(False)
        self.spb_lowpass.setEnabled(False)
        self.cbx_scharr.setEnabled(False)
        self.cbx_median.setEnabled(False)

        self.rdo_global_threshold.setEnabled(False)
        self.sld_global_threshold.setEnabled(False)
        self.rdo_adaptive_threshold.setEnabled(False)
        self.spb_adaptive_threshold.setEnabled(False)
        self.rdo_otsu_threshold.setEnabled(False)
        self.cbx_dark_foreground.setEnabled(False)
        self.tree_settings.setEnabled(False)

    def enable_all_tasks(self):
        """
        Enable all buttons and controls.

        :return:
        """
        if not self.wait_flag:
            self.enable_path_controls()
            if len(self.graph_objs) > 0:
                self.btn_cancel.setEnabled(False)  # Opposite of others
                self.enable_filter_controls()
                self.enable_img_tasks()
                if not self.error_flag:
                    self.enable_gt_tasks()

    def enable_path_only(self):
        """
        Enable only path select buttons.
        :return:
        """
        self.disable_all_tasks()
        self.btn_cancel.setEnabled(False)  # Opposite of others
        self.enable_path_controls()

    def enable_path_controls(self):
        """Allow multi-image path selection if and only if image-dimension is 2D."""
        options_img = self.configs_data["filter_options"]

        self.rdo_2d_img.setEnabled(True)
        self.rdo_3d_img.setEnabled(True)
        self.btn_select_img_path.setEnabled(True)
        self.btn_select_out_path.setEnabled(True)

        if options_img.image_dimensions == 2:
            self.cbx_multi.setEnabled(True)
        else:
            self.cbx_multi.setEnabled(False)
            self.cbx_multi.setChecked(False)

    def enable_filter_controls(self):
        """Enable all filter controls"""
        self.txt_scalebar_val.setEnabled(True)
        self.txt_scalebar_px.setEnabled(True)
        self.txt_resistivity.setEnabled(True)

        self.spb_brightness.setEnabled(True)
        self.spb_contrast.setEnabled(True)

        self.sld_lut_gamma.setEnabled(True)
        self.cbx_gaussian_blur.setEnabled(True)
        self.sld_gaussian.setEnabled(True)
        self.cbx_autolevel.setEnabled(True)
        self.sld_autolevel.setEnabled(True)
        self.cbx_laplacian.setEnabled(True)
        self.sld_laplacian.setEnabled(True)
        self.cbx_sobel.setEnabled(True)
        self.sld_sobel.setEnabled(True)
        self.cbx_lowpass.setEnabled(True)
        self.spb_lowpass.setEnabled(True)
        self.cbx_scharr.setEnabled(True)
        self.cbx_median.setEnabled(True)

        self.rdo_global_threshold.setEnabled(True)
        self.sld_global_threshold.setEnabled(True)
        self.rdo_adaptive_threshold.setEnabled(True)
        self.spb_adaptive_threshold.setEnabled(True)
        self.rdo_otsu_threshold.setEnabled(True)
        self.cbx_dark_foreground.setEnabled(True)
        self.tree_settings.setEnabled(True)

    def enable_img_tasks(self):
        """
        Enable image controls and buttons.
        :return:
        """

        self.btn_cancel.setEnabled(False)

        self.btn_zoom_in.setEnabled(True)
        self.btn_zoom_out.setEnabled(True)
        if self.cbx_multi.isChecked():
            self.btn_next.setEnabled(True)
            self.btn_prev.setEnabled(True)

        self.spb_contrast.setEnabled(True)
        self.spb_brightness.setEnabled(True)

        # self.btn_reset_filters.setEnabled(True)
        self.btn_crop.setEnabled(True)

        self.cb_show_img.setEnabled(True)
        self.btn_show_graph.setEnabled(True)
        self.btn_quick_graph_metrics.setEnabled(True)
        self.btn_save_files.setEnabled(True)

    def enable_gt_tasks(self):
        """
        Enable GT controls and buttons.

        :return:
        """
        self.btn_cancel.setEnabled(False)

        self.cbx_igraph.setEnabled(True)
        self.btn_gt_metrics.setEnabled(True)
        if self.cbx_multi.isChecked():
            self.btn_gt_metrics_all.setEnabled(True)
        else:
            self.btn_gt_metrics_all.setEnabled(False)
        # self.btn_chaos_gt.setEnabled(True)

    def write_gt_pdf(self, plot_figs):
        """
        Write results to PDF file.

        :param plot_figs:
        :return:
        """
        try:
            self._handle_progress_update(98, 98, "Writing PDF...")
            g_obj = self.graph_objs[self.current_obj_index]
            filename, output_location = g_obj.imp.create_filenames()
            pdf_filename = filename + "_SGT_results.pdf"
            pdf_file = os.path.join(output_location, pdf_filename)
            with (PdfPages(pdf_file) as pdf):
                for fig in plot_figs:
                    pdf.savefig(fig)
            self.graph_objs[self.current_obj_index].save_files()
        except IndexError:
            dialog = CustomDialog("Write Error", "Unable to write PDF results. Try again.")
            dialog.exec()


class TreeItem(QtGui.QStandardItem):

    def __init__(self, text='', font_size=11, set_bold=False, set_checkable=False, color=QtGui.QColor(0, 0, 0), data=0):
        super().__init__()

        font = QtGui.QFont()
        font.setPointSize(font_size)
        font.setBold(set_bold)

        self.setEditable(False)
        self.setForeground(color)
        self.setFont(font)
        self.setText(text)
        self.setCheckable(set_checkable)
        self.setData(data)

        if int(self.data()) == 1:
            self.setCheckState(QtCore.Qt.CheckState.Checked)
            # self.setData(QtCore.Qt.CheckState.Checked, QtCore.Qt.ItemDataRole.CheckStateRole)
        elif int(self.data()) == 0:
            self.setCheckState(QtCore.Qt.CheckState.Unchecked)
            # self.setData(QtCore.Qt.CheckState.Unchecked, QtCore.Qt.ItemDataRole.CheckStateRole)


class TreeTextItem(QtGui.QStandardItem):

    def __init__(self, text='', font_size=9, set_bold=False, set_editable=False, color=QtGui.QColor(0, 0, 0)):
        super().__init__()

        font = QtGui.QFont()
        font.setPointSize(font_size)
        font.setBold(set_bold)

        self.setEditable(set_editable)
        self.setForeground(color)
        # self.setData(color, QtCore.Qt.ItemDataRole.ForegroundRole)
        self.setFont(font)
        self.setText(text)


class TreeRadioItemDelegate(QtWidgets.QStyledItemDelegate):
    # Apply Radio Button behavior
    # def paint(self, painter, option, index):
    #    if index.data(QtCore.Qt.ItemDataRole.UserRole) == "RdoItem_Wt":
    #        widget = option.widget
    #        style = widget.style() if widget else QtWidgets.QApplication.style()
    #        opt = QtWidgets.QStyleOptionButton()
    #        opt.rect = option.rect
    #        opt.text = index.data()
    #        opt.state |= QtWidgets.QStyle.StateFlag.State_On if index.data(QtCore.Qt.ItemDataRole.CheckStateRole)else(
    #            QtWidgets.QStyle.StateFlag.State_Off)

    #       style.drawControl(QtWidgets.QStyle.ControlElement.CE_RadioButton, opt, painter, widget)
    #   else:
    #       QtWidgets.QStyledItemDelegate.paint(self, painter, option, index)

    # Apply Radio Button behavior
    def editorEvent(self, event, model, option, index):
        value = QtWidgets.QStyledItemDelegate.editorEvent(self, event, model, option, index)
        if value and (index.data(QtCore.Qt.ItemDataRole.UserRole) == "RdoItem_Wt"):
            if event.type() == QtCore.QEvent.Type.MouseButtonRelease:
                if index.data(QtCore.Qt.ItemDataRole.CheckStateRole):
                    parent = index.parent()
                    for i in range(model.rowCount(parent)):
                        if i != index.row():
                            ix = index.sibling(i, 0)
                            model.setData(ix, False, QtCore.Qt.ItemDataRole.CheckStateRole)
        return value


class CustomQLabel(QtWidgets.QLabel):
    textChanged = QtCore.pyqtSignal(str)

    def setText(self, text):
        super().setText(text)
        self.textChanged.emit(text)


class CustomDialog(QtWidgets.QDialog):
    def __init__(self, title, message, parent=None):
        super().__init__(parent)

        self.setWindowTitle(title)

        dialog_button = QtWidgets.QDialogButtonBox.StandardButton.Ok | QtWidgets.QDialogButtonBox.StandardButton.Cancel

        self.buttonBox = QtWidgets.QDialogButtonBox(dialog_button)
        self.buttonBox.accepted.connect(self.accept)
        self.buttonBox.rejected.connect(self.reject)

        self.layout = QtWidgets.QVBoxLayout()
        message = QtWidgets.QLabel(message)
        self.layout.addWidget(message)
        self.layout.addWidget(self.buttonBox)
        self.setLayout(self.layout)


class WorkerSignals(QtCore.QObject):
    progress = QtCore.pyqtSignal(int, int, str)
    finished = QtCore.pyqtSignal(int, int, object)


class Worker(QtCore.QThread):
    def __init__(self, func_id, args, target=None):
        super().__init__()
        self.__listeners = []
        self.signals = WorkerSignals()
        self.target = target
        self.target_id = func_id
        self.args = args
        self.abort = False

    def add_thread_listener(self, func):
        """
        Add functions from the list of listeners.
        :param func:
        :return:
        """
        if func in self.__listeners:
            return
        self.__listeners.append(func)

    def remove_thread_listener(self, func):
        """
        Remove functions from the list of listeners.
        :param func:
        :return:
        """
        if func not in self.__listeners:
            return
        self.__listeners.remove(func)

    # Trigger events.
    def send_abort_message(self, args=None):
        self.abort = True
        if args is None:
            args = []
        for func in self.__listeners:
            func(*args)

    def run(self):
        if self.target:
            self.target(*self.args)
        if self.target_id == 0:
            self.service_filter_img(*self.args)
        elif self.target_id == 1:
            self.service_generate_graph(*self.args)
        elif self.target_id == 2:
            self.service_compute_gt(*self.args)
        elif self.target_id == 3:
            self.service_compute_gt_all(*self.args)
        elif self.target_id == 4:
            self.signals.finished.emit(3, 1, "Test complete!")

    def update_progress(self, value, msg):
        if value > 0:
            self.signals.progress.emit(value, value, msg)
        else:
            self.signals.progress.emit(0, value, msg)

    def service_filter_img(self, img_path, output_path, options_img, img):
        try:
            self.update_progress(10, "applying filters...")
            img_dim = options_img.image_dimensions
            im_obj = ImageProcessor(img_path, output_path, img_dim, options_img=options_img, img=img)
            im_obj.apply_filters()
            self.update_progress(100, '')
            self.signals.finished.emit(0, 0, im_obj)
            # graph_obj = GraphConverter(im_obj, options_gte=options_gte)
            # graph_obj.add_listener(self.update_progress)
            # graph_obj.fit_img()
            # graph_obj.remove_listener(self.update_progress)
            # self.signals.finished.emit(1, 0, graph_obj)
        except Exception as err:
            print(err)
            logging.exception("Error: %s", err, extra={'user': 'SGT Logs'})
            self.abort = True
            self.update_progress(-1, "Error encountered! Try again")
            self.signals.finished.emit(0, 1, [])

    def service_generate_graph(self, graph_obj, options_img, options_gte):
        try:
            graph_obj.abort = False
            graph_obj.imp.configs_img = options_img
            graph_obj.configs_graph = options_gte
            graph_obj.add_listener(self.update_progress)
            self.add_thread_listener(graph_obj.abort_tasks)
            graph_obj.fit()
            graph_obj.remove_listener(self.update_progress)
            self.add_thread_listener(graph_obj.abort_tasks)
            self.signals.finished.emit(1, 0, graph_obj)
        except Exception as err:
            print(err)
            logging.exception("Error: %s", err, extra={'user': 'SGT Logs'})
            self.abort = True
            self.update_progress(-1, "Error encountered! Try again")
            self.signals.finished.emit(1, 1, [])

    def service_compute_gt(self, graph_obj, options_img, options_gte, options_gtc):
        try:
            graph_obj.abort = False
            if graph_obj.nx_graph is None:
                graph_obj.imp.configs_img = options_img
                graph_obj.configs_graph = options_gte
                graph_obj.add_listener(self.update_progress)
                self.add_thread_listener(graph_obj.abort_tasks)
                graph_obj.fit()
                graph_obj.remove_listener(self.update_progress)
                self.add_thread_listener(graph_obj.abort_tasks)
            else:
                if graph_obj.nx_graph.number_of_nodes() <= 0:
                    self.update_progress(-1, "Graph Error: Problem with graph (change/apply different filter and "
                                             "graph options). Or change brightness/contrast")
                    return
            if self.abort:
                self.update_progress(-1, "Task aborted.")
                self.signals.finished.emit(2, 1, [])
                return
            graph_obj.configs_graph = options_gte
            if options_gtc.compute_lang == 'C':
                metrics_obj = GraphMetricsClang(graph_obj, options_gtc)
            else:
                metrics_obj = GraphMetrics(graph_obj, options_gtc)
            metrics_obj.add_listener(self.update_progress)
            self.add_thread_listener(metrics_obj.abort_tasks)
            metrics_obj.compute_gt_metrics()
            if options_gte.has_weights:
                if self.abort:
                    self.update_progress(-1, "Task aborted.")
                    self.signals.finished.emit(2, 1, [])
                    return
                metrics_obj.compute_weighted_gt_metrics()
            # metrics_obj.generate_pdf_output()
            if self.abort:
                self.update_progress(-1, "Task aborted.")
                self.signals.finished.emit(2, 1, [])
                return
            plot_figs = metrics_obj.generate_pdf_output(gui_app=True)
            metrics_obj.remove_listener(self.update_progress)
            self.remove_thread_listener(metrics_obj.abort_tasks)
            self.signals.finished.emit(2, 1, plot_figs)
        except Exception as err:
            print(err)
            logging.exception("Error: %s", err, extra={'user': 'SGT Logs'})
            self.abort = True
            self.update_progress(-1, "Error encountered! Try again")
            self.signals.finished.emit(2, 1, [])

    def service_compute_gt_all(self, graph_objs, out_path, options_img, options_gte, options_gtc):
        i = 0
        for graph_obj in graph_objs:
            start = time.time()

            if self.abort:
                self.update_progress(-1, "Task aborted.")
                self.signals.finished.emit(3, 0, [])
                return
            try:
                graph_obj.abort = False
                if graph_obj.nx_graph is None:
                    graph_obj.imp.configs_img = options_img
                    graph_obj.configs_graph = options_gte
                    graph_obj.add_listener(self.update_progress)
                    graph_obj.fit()
                    graph_obj.remove_listener(self.update_progress)
                    self.add_thread_listener(graph_obj.abort_tasks)
                else:
                    if graph_obj.nx_graph.number_of_nodes() <= 0:
                        self.update_progress(-1, "Graph Error: Problem with graph (change/apply different filter and "
                                                 "graph options). Or change brightness/contrast")
                        return
                if self.abort:
                    self.update_progress(-1, "Task aborted.")
                    self.signals.finished.emit(3, 0, [])
                    return
                graph_obj.configs_graph = options_gte
                graph_obj.imp.output_path = out_path
                if options_gtc.compute_lang == 'C':
                    metrics_obj = GraphMetricsClang(graph_obj, options_gtc)
                else:
                    metrics_obj = GraphMetrics(graph_obj, options_gtc)
                metrics_obj.add_listener(self.update_progress)
                self.add_thread_listener(metrics_obj.abort_tasks)
                metrics_obj.compute_gt_metrics()
                if options_gte.has_weights:
                    if self.abort:
                        self.update_progress(-1, "Task aborted.")
                        self.signals.finished.emit(3, 0, [])
                        return
                    metrics_obj.compute_weighted_gt_metrics()
                if self.abort:
                    self.update_progress(-1, "Task aborted.")
                    self.signals.finished.emit(3, 0, [])
                    return
                # metrics_obj.generate_pdf_output()
                plot_figs = metrics_obj.generate_pdf_output(gui_app=True)
                metrics_obj.remove_listener(self.update_progress)
                self.add_thread_listener(metrics_obj.abort_tasks)
                self.signals.finished.emit(2, 0, plot_figs)

                end = time.time()
                num_cores = get_num_cores()
                i += 1
                output = "Analyzing Image:" + str(i) + "/" + str(len(graph_objs)) + "\n"
                output += "Run-time: " + str(end - start) + " seconds" + "\n"
                output += "Number of cores: " + str(num_cores) + "\n"
                output += "Results generated for: " + graph_obj.imp.img_path + "\n"
                output += "Node Count: " + str(graph_obj.nx_graph.number_of_nodes()) + "\n"
                output += "Edge Count: " + str(graph_obj.nx_graph.number_of_edges()) + "\n"
                filename, out_dir = graph_obj.imp.create_filenames()
                out_file = os.path.join(out_dir, filename + '-v2_results.txt')
                write_file(output, out_file)
                print(output)
                logging.info(output, extra={'user': 'SGT Logs'})
            except Exception as err:
                print(err)
                logging.exception("Error: %s", err, extra={'user': 'SGT Logs'})
                self.abort = True
                self.update_progress(-1, "Error encountered! Try again")
                self.signals.finished.emit(3, 0, [])
        self.signals.finished.emit(3, 1, [])


def pyqt_app():
    """
    Initialize and start StructuralGT graphical application.

    :return: None
    """
    app = QtWidgets.QApplication(sys.argv)
    sgt_ui = MainUI()
    sgt_ui.show()
    sys.exit(app.exec())
